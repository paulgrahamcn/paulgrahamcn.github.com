---
layout: post
title : "第13章--速度"
category : acl
tags : [acl]
---
{% include JB/setup %}

Lisp 实际上是两种语言：一种能写出快速执行的程序，一种则能让你快速的写出程序。
在程序开发的早期阶段，你可以为了开发上的便捷舍弃程序的执行速度。一旦程序的结构开始固化 (crystallize)，你就可以精炼其中的关键部分以使得它们执行的更快。<br/><br/>
由于各个 Common Lisp 实现 (implementation) 间的差异，很难针对优化 (optimization)给出通用的建议。在一个实现上使程序变快的修改也许在另一个实现上会使得程序变慢。
这是难免的事儿。 (This is something that comes with the territory.)
越强大的语言，离机器底层就越远，离机器底层越远，语言的不同实现沿着不同路径趋向它的可能性就越大。因此，即便有一些技巧几乎一定能够让程序运行的更快，本章的目的也只是建议而不是指导 (prescribe)。<br/><br/>

<h1>13.1 瓶颈规则 (The Bottleneck Rule)</h1>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 15)<br/><br/>
Title underline too short.<br/><br/>

13.1 瓶颈规则 (The Bottleneck Rule)
==================================
</pre>

不管实现如何，关于优化可以整理出三点规则：它应该关注瓶颈，它不应该开始的太早，它应该始于算法。<br/><br/>
也许关于优化最重要的事情就是要认识到程序执行中相当大的一部分时间都是由少数的瓶颈引起的。
根据 <a class="reference external" href="http://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a> ， “在一个与I/O无关 (Non-I/O bound) 的程序中大部分的运行时间集中在大概 3% 的源代码中。” <a class="reference external" href="http://ansi-common-lisp.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-213">λ</a> 优化程序的这一部分将会使得它的运行速度明显的提升；相反，优化程序的其他部分将是在浪费时间。<br/><br/>
因此，优化程序时关键的第一步就是找到瓶颈。
许多 Lisp 实现都提供剖析器 (profiler) 来监视程序的运行并报告每一部分所花费的时间量。
剖析器是非常重要的 -- 甚至是必不可少的 -- 生产最为高效代码的有力工具。
如果你的 Lisp 实现提供了一个，使用它来指引你完成优化吧。如果没有，你不得不通过猜测来寻找瓶颈。
但也许你会惊异的发现猜不中的机会是那么的高！<br/><br/>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 5); <em><a href="#id2">backlink</a></em><br/><br/>
Duplicate explicit target name: &quot;λ&quot;.
瓶颈规则的一个推论是你不应该在程序的早期花费太多的精力在优化上。 <a class="reference external" href="http://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a> 对此甚至更加深信不疑：“
过早的优化是一切 (至少是大多数) 问题的源头。” <a class="reference external" href="http://ansi-common-lisp.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-214">λ</a> 在你刚开始写程序的时候很难看清它真正的瓶颈在哪，因此，如果这个时候进行优化，你很可能是在浪费时间。
优化也容易使程序的修改更加困难，试图边写程序边优化就像是试图用干的太快的颜料来作画。<br/><br/>
在合适的时间集中精力搞好该做的事情将会让你写出更优秀的程序。
Lisp 的一个优点就是能让你用不同的速度工作：很快的写出运行速度较慢代码或慢慢的写运行速度较快的代码。
在程序开发的早期阶段，你趋向工作在前一种模式下，然后当优化摆在眼前时，你切换到后一种模式工作。
对于非常底层的语言，如汇编，你必须优化程序的每一行。但这么做会浪费你大部分的精力，因为瓶颈仅仅是其中很小的那部分代码。
一个更加抽象的语言能够让你把主要精力集中在瓶颈上， 达到事半功倍的效果。<br/><br/>
当你真的面对优化时，还要从最顶端入手。
在开始采用各种低阶的编码技巧 (low-level coding tricks) 前先确保你已经使用了最为高效的算法。
这么做潜在的好处相当大--甚至可能大到你都不再需要玩那些奇淫技巧。
当然本规则还是要和前一个规则保持平衡。有些时候必须在早期决定使用的算法。<br/><br/>


<h1>13.2 编译 (Compilation)</h1>
有五个参数 (parameter) 可以控制代码的编译： <em>speed</em> (速度) 代表编译器产生代码的速度；
<em>compilation-speed</em> (编译速度) 代表程序被编译的速度； <em>safety</em> (安全) 代表目标代码中进行错误检查的数量；
<em>space</em> (空间) 代表目标代码的大小和内存需求量；最后， <em>debug</em> (调试) 代表为了调试而保留的信息量。<br/><br/>

交互 与 解释 (INTERACTIVE VS. INTERPRETED)

Lisp 是一种交互式语言 (Interactive Language), 但是交互式的语言不必都是解释型 (Interpreted) 的。
早期的 Lisp 都通过解释器实现， 因此认为 Lisp 的特质都依赖于它是被解释的想法就这么产生了。但这种
想法是错误的：Common Lisp 既是编译型又是解释型的语言。

至少有两种 Common Lisp 实现甚至都不包含解释器 (interpreter)。在这些实现中，输入到顶层 (toplevel) 的表达式
在求值前被编译。因此，把顶层叫做解释器的不光是落伍的说法，甚至是错误的说法。
</pre>
编译参数 (compilation parameter) 不是真正的变量。它们在声明中被分配从 0 (最不重要) 到 3 (最重要) 的权值 (weight)。
如果一个主要的瓶颈发生在某个函数的内层循环 (inner loop) 中，我们或许可以添加如下的声明：<br/><br/>
<dl class="docutils">
<dt>::</dt>
<dd><dl class="first last docutils">
<dt>(defun bottleneck (...)</dt>
<dd><dl class="first last docutils">
<dt>(do (...)</dt>
<dd><blockquote class="first">
(...)</blockquote>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 70)<br/><br/>
Block quote ends without a blank line; unexpected unindent.
<dl class="last docutils">
<dt>(do (...)</dt>
<dd><blockquote class="first">
(...)</blockquote>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 72)<br/><br/>
Block quote ends without a blank line; unexpected unindent.
(declare (optimize (speed 3) (safety 0)))
...)))<br/><br/>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
一般来讲你不会愿意在代码写完和测试通过前就加上这么一句声明。<br/><br/>
你也可以不管不顾的在全局要求所有的代码都尽可能的快，如下：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 79)<br/><br/>
Unexpected indentation.

(declaim (optimize (speed 3)
                   (compilation-speed 0)
                   (safety 0)
                   (debug 0)))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 83)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
这么做是相当极端的，考虑到瓶颈规则 <a class="footnote-reference" href="#id8" id="id3">[1]</a> 甚至恐怕没有必要这么做。<br/><br/>
另一类特别重要的优化就是由 Lisp 编译器完成的尾调用优化 (the optimization of tail calls)。
当 <em>speed</em> (速度) 的权值最大时所有支持尾调用优化的编译器都将保证对代码进行这种优化。<br/><br/>
如果在一个调用返回时调用者中没有残余的计算，该调用就被称为尾调用。下面的代码返回列表 (list) 的长度：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 90)<br/><br/>
Unexpected indentation.

(defun length/r (lst)
   (if (null lst)
      0
      (1+ (length/r (cdr lst)))))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 94)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
这个递归调用不是尾调用，因为当它返回以后，它的值必须传给 <em>1+</em> 。相反，这是一个尾递归的版本，<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 96)<br/><br/>
Unexpected indentation.

(defun length/rt (lst)
   (labels ((len (lst acc)
              (if (null lst)
                  acc
                  (len (cdr lst) (1+ acc)))))
     (len lst 0)))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 102)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
或者更准确的说，局部函数 (local function) <em>len</em> 是尾递归调用，因为在递归调用返回时没有什么其他
的事情发生了。和 <em>length/r</em> 不同的是，它不是在递归回溯的时候构建返回值，而是在递归调用的过程中积累返回值。
所以额外的 <em>acc</em> 参数，在最后一层递归调用结束后就可以简单的返回。<br/><br/>
出色的编译器能够将一个尾调用编译成一个跳转 (goto)，因此也能将一个尾递归函数编译成一个循环 (loop)。在典型的机器语言代码中 (machine language code)，当第一次执行到表示 <em>len</em> 的指令片段 (the segment of instructions) 时，栈上会有信息指示在返回时要做些什么。
由于在递归调用后没有残余的计算，该信息对第二层调用仍然有效：第二层调用返回后我们要做的仅仅就是从第一层调用返回。
因此，当要进行第二层调用时，我们只需给参数设置新的值，然后跳转到函数的起始处继续执行，没有必要进行真正的函数调用。<br/><br/>
另一个利用函数调用抽象 (abstraction of function calls) 而又没有开销的方法是使函数内联编译 (compiled inline)。
针对调用开销比函数体的执行代价还高的小型函数来说这非常有价值。例如，下面的代码判断是否是仅含有一个元素的列表：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 113)<br/><br/>
Unexpected indentation.

(declaim (inline single?))
(defun single? (lst)
   (and (consp lst) (null (cdr lst))))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 116)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
因为这个函数是在全局被声明为内联的，引用了 <em>single?</em> 的函数在编译后将不需要真正的函数调用。 <a class="footnote-reference" href="#id5" id="id4">[2]</a> 如果我们定义一个调用它的函数,<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 118)<br/><br/>
Unexpected indentation.

(defun foo (x)
  (single? (bar x)))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 120)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
当 <em>foo</em> 被编译后， <em>single?</em> 函数体中的代码将会被编译进 <em>foo</em> 的函数体，就好像我们直接写：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 122)<br/><br/>
Unexpected indentation.

(defun foo (x)
  (let ((lst (bar x)))
    (and (consp lst) (null (cdr lst)))))
</pre>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>为了让内联声明 (inline declaration) 有效，你同时必须设置编译参数，告诉它你想获得最快的代码。</td></tr>
</tbody>
</table>
内联编译 (inline compilation) 有两个限制。递归函数不能内联。另外如果一个内联函数被重新定义，我们就必须
重新编译调用它的任何函数，否则调用仍然使用原先的定义。<br/><br/>
在一些早期Lisp方言中，有些使用宏 (macros) (10.2 节) 来避免函数调用。通常认为在 Common Lisp 中这么做是没有必要的。<br/><br/>
不同的Lisp编译器做的优化也千差万别。如果你想了解你的编译器为某个函数生成的代码，试着调用 <em>disassemble</em> 。
该函数接受一个函数或者函数名并显示它编译后的形式 (compiled form)。即便你看到的东西是完全无法理解的，
你仍然可以使用 <em>disassemble</em> 来判断声明是否起效果：编译函数的两个版本，一个使用声明一个不使用，
然后观察由 <em>disassemble</em> 显示的两组代码之间是否有差异。你也可以用类似的技巧来查看函数是否被内联编译了。
不管那种情况，确保事先设置编译参数来获得最快的代码。<br/><br/>


<h1>13.3 类型声明 (Type Declarations)</h1>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 140)<br/><br/>
Title underline too short.<br/><br/>

13.3 类型声明 (Type Declarations)
================================
</pre>

如果Lisp是你所学的第二门编程语言，你也许会感到困惑我们为何还未谈及类型声明这件事儿，
毕竟它在其他一些编程语言中是那样盛行且必要。<br/><br/>
在大多数编程语言中，你必须为每个变量声明类型，并且变量也只可以有与之类型相一致的值。
这种语言被称为 <em>强类型</em> ( <em>strongly typed</em> ) 的。除了给程序员们徒增了许多负重外，这种
方式还限制了你能做的事情。使用这种语言，很难写出可以和不同种类的参数一起工作的函数，也
很难定义出可以包含不同种类元素的数据结构。当然，这种方式也有它的优势，比如无论何时当编译
器碰到一个加法运算，它都能够事先知道这是一个什么类型的加法运算。如果两个参量都是整数类型，
编译器可以直接在目标代码中生成一个固定 (hard-wire) 的整数加法运算。<br/><br/>
正如 2.15 节讲的那样，Common Lisp 使用一种更加灵活的方式：显示类型 (manifest typing) <a class="footnote-reference" href="#id7" id="id6">[3]</a> 。
有类型的是值而不是变量。变量可以用于任何类型的对象。<br/><br/>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[3]</a></td><td>有两种方法可以描述Lisp声明类型 (typing) 的方式：从类型信息被存放的位置或者从它被使用的时间。
显示类型 (manifest typing) 的意思是类型信息与数据对象 (data objects) 绑定，而运行时类型
(run-time typing) 的意思是类型信息在运行时被使用。实际上，两者是一回事儿。</td></tr>
</tbody>
</table>
如果我们仅仅如此，就不得不为了灵活性牺牲速度。由于 <em>+</em> 可以接受好几种不同类型的数，它不得不
在运行时查看每个参量的类型来决定采用哪种加法运算。<br/><br/>
如果我们只是想要一个整数加法运算，这将是一种低效的方法。Common Lisp 的方式是：把你所知道的尽可能都告诉我。
如果我们提前就能知道某个加法运算的两个参数是定长数 (fixnums) ，我们就可以对此进行声明，
这样编译器就会像C语言的那样为我们生成一个固定的整数加法运算。<br/><br/>
因此，这两种声明类型 (typing) 的方式不会在运行速度上有什么差别。区别仅仅是在第一种方式中
类型声明是强制性的，而第二种则不对你强加这样的要求。在 Common Lisp 中类型声明完全是可选的。
它们可以让程序运行的更快，但(除非错误)不会改变程序的行为。<br/><br/>
全局声明 (global declarations) 通过 <em>declaim</em> 和其后的一个或多个声明形式 (declaration forms) 实现。
一个类型声明由包含了符号 (symbol) <em>type</em> ，紧接其后的一个类型名 (type name) 以及后面一个或多变量的
列表 (list) 构成。因此，如果要声明一个全局变量的类型，你可以这么写：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 174)<br/><br/>
Unexpected indentation.

(declaim (type fixnum *count*))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 175)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
在 ANSI Common Lisp 中，你可以省略 <em>type</em> 简写为：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 177)<br/><br/>
Unexpected indentation.

(declaim (fixnum *count*))
</pre>
局部声明 (local declarations) 可以通过 <em>declare</em> 完成，其后参数与 <em>declaim</em> 的相同。声明可以在任何
变量刚刚被创建出来的代码体前进行：如 <em>defun</em> 、 <em>lambda</em> 、 <em>let</em> 、 <em>do</em> 等等。例如，要把一个函数
的参数声明为定长数，我们可以这么写：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 183)<br/><br/>
Unexpected indentation.

(defun poly (a b x)
   (declare (fixnum a b x))
   (+ (* a (expt x 2)) (* b x)))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 186)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
在类型声明中的变量名指的就是该声明所在的上下文中的那个变量 -- 那个通过赋值可以改变它的值的变量。<br/><br/>
你也可以通过 <em>the</em> 为某个表达式的值声明类型。
如果我们提前就知道 <em>a</em> 、 <em>b</em> 和 <em>x</em> 是足够小的定长数以至于相互运算的中间结果也都是定长数的话，
我们可以这么写：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 192)<br/><br/>
Unexpected indentation.

(defun poly (a b x)
   (declare (fixnum a b x))
   (the fixnum (+ (the fixnum (* a (the fixnum (expt x 2))))
                  (the fixnum (* b x)))))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 196)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
看起来是不是很笨拙啊？幸运的是有两个原因让你很少会这样使用 <em>the</em> 把你的数值运算代码变得散乱不堪。
其一是很容易通过宏 (macros) 帮你插入这些声明。其二是某些实现使用了特殊的技巧，即便没有类型声明
的定长数运算也能足够快。<br/><br/>
Common Lisp 中有相当多的类型--恐怕有无数种类型那么多，如果考虑到你可以自己定义新的类型的话。但声明
只在少数情况下至关重要，什么时候值得去做类型声明呢？我们可以遵照以下两条规则：<br/><br/>
<blockquote>
<ol class="arabic simple">
<li>当函数可以接受若干不同类型的参数 (但不是所有类型) 时，可以对参数的类型进行声明。如果你知道一个
对 <em>+</em> 的调用总是接受定长数类型的参数，或者一个对 <em>aref</em> 的调用第一个参数总是某种特定种类的数组 (array)
，那么进行类型声明是值得的。</li>
<li>通常只有对类型层级 (type hierarchy) 中接近底层的类型进行声明是值得的：将某个东西的类型声明为
<em>fixnum</em> 或者 <em>simple-array</em> 也许有用，但将某个东西的类型声明为 <em>integer</em> 或者 <em>sequence</em> 或许就没用了。</li>
</ol>
</blockquote>
类型声明对内容复杂的对象特别重要，这包括数组 (arrays)、结构 (structures) 和实例 (instances)。
这些声明可以在两个方面提升效率：除了可以让编译器来决定函数参数的类型以外，它们也使得在内存中用更为高效的方
式表示这些对象成为可能。<br/><br/>
如果对数组元素的类型一无所知的话，这些元素在内存中就不得不用一组指针 (a block of pointers) 来表示。
但假如预先就知道数组包含的元素仅仅是 -- 比方说 -- 双精度浮点数 (double-floats)，那么这个数组就可以用一组实际的
双精度浮点数来表示。这样数组将占用更少的空间，因为我们不再需要额外的指针指向每一个双精度浮点数；同时，
对数组元素的访问也将更快，因为我们不必沿着指针去读取和写元素。<br/><br/>
<img alt="../images/Figure-13.1.png" src="../images/Figure-13.1.png" />
你可以通过 <em>make-array</em> 的 <em>:element-type</em> 参数指定数组包含值的种类。这样的数组被称为 <em>特化数组</em> (specialized array)。
图 13.1 为我们展示了如下代码在多数实现上求值后发生的事情：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 224)<br/><br/>
Unexpected indentation.

(setf x (vector 1.234d0 2.345d0 3.456d0)
      y (make-array 3 :element-type 'double-float)
      (aref y 0) 1.234d0
      (aref y 1) 2.345d0
      (aref y 2）3.456d0))
</pre>
图 13.1 中的每一个矩形方格代表内存中的一个字 (a word of memory)。这两个数组都由未特别指明长度的头部 (header) 以及后续
三个元素的某种表示构成。对于 <em>x</em> 来说，每个元素都由一个指针表示。此时每个指针碰巧都指向双精度浮点数，但实际上
我们可以存储任何类型的对象到这个向量 (vector) 中。对 <em>y</em> 来说，每个元素实际上都是双精度浮点数。 <em>y</em> 更快而且占用更少
空间，但意味着它的元素只能是双精度浮点数。<br/><br/>
注意我们使用 <em>aref</em> 来引用 <em>y</em> 的元素。一个特化的向量不再是一个简单向量 (simple vector)，因此我们不再能够通过 <em>svref</em>
来引用它的元素。<br/><br/>
除了在创建数组时指定元素的类型，你还应该在使用数组的代码中声明数组的维度 (dimensions) 以及它的元素类型。
一个完整的向量声明如下：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 241)<br/><br/>
Unexpected indentation.

(declare (type (vector fixnum 20) v))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 242)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
声明一个仅含有定长数且长度固定为 20 的向量。<br/><br/>

(setf a (make-array '(1000 1000)
                    :element-type 'single-float
                    :initial-element 1.0s0))

(defun sum-elts (a)
  (declare (type (simple-array single-float (1000 1000))
                 a))
  (let ((sum 0.0s0))
    (declare (type single-float sum))
    (dotimes (r 1000)
      (dotimes (c 1000)
        (incf sum (aref a r c))))
    sum))
</pre>
<strong>图 13.2 对数组元素求和</strong><br/><br/>
最为通用的数组声明形式由数组类型以及紧接其后的元素类型和一个维度列表构成：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 264)<br/><br/>
Unexpected indentation.

(declare (type (simple-array fixnum (4 4)) ar))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 265)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
图 13.2 展示了如何创建一个 1000*1000 的单精度浮点数数组，以及如何编写一个将该数组元素相加的函数。
数组以行主序 (row-major order)存储，遍历时也应尽可能以此序进行。<br/><br/>
我们将用 <em>time</em> 来比较 <em>sum-elts</em> 在有声明和无声明两种情况下的性能。
<em>time</em> 宏显示表达式求值所花费时间的某种度量(some measure) (依赖于实现)。对被编译的函数求取时间才是有意义的。
在某个实现中，如果我们以获取最快速代码的编译参数编译 <em>sum-elts</em> ，它将在不到半秒的时间内返回：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 272)<br/><br/>
Unexpected indentation.

&gt; (time (sum-elts a))
User Run Time = 0.43 seconds
1000000.0
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 275)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
如果我们把 <em>sum-elts</em> 中的类型声明去掉并重新编译它，同样的计算将花费超过5秒的时间：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 277)<br/><br/>
Unexpected indentation.

&gt; (time (sum-elts a))
User Run Time = 5.17 seconds
1000000.0
</pre>
类型声明的重要性 -- 特别是对数组和数来说 -- 怎么强调都不过分。上面的例子中，仅仅两行代码就可以让 <em>sum-elts</em> 变快 12 倍。<br/><br/>


<h1>13.4 避免垃圾 (Garbage Avoidance)</h1>
就像Lisp允许你推后对变量类型的考虑一样，它也允许你推后对内存分配 (memory allocation) 的考虑。在程序的早期阶段
不用去考虑内存分配 (或者棘手的 bug) 将解放你的想象力。当程序成熟时，你可以让它依赖更少的动态分配而变得更快。<br/><br/>
然而，较少的构造 (consing) 并不总是让程序更快。对于那些依赖着低端 (bad) 垃圾回收器 (garbage collector) 的Lisp实现来说，过多的
构造 (cons) 容易让程序运行缓慢。多数Lisp实现一直都还使用着低端垃圾回收器，因此高效的程序应尽可能少的构造就变成了一种
传统。最近的发展完全改变了这种传统观念。一些实现上现在已经拥有了相当先进 (sophisticated) 的垃圾回收器，它构造新对象然后
抛弃而不是回收这些对象，这样就会更高效。<br/><br/>
本节介绍几种减少程序中的构造的方法。 但是否构造少了就能让你的程序运行的更快还依赖于实现。最佳忠告依然是自己去试一下吧。
为了减少构造你需要做很多事。有些不会改变你程序的形状。例如，其中最简单的就是使用解构函数 (destructive function)。
下表中罗列一些常用的函数以及与它们对应的解构版本。<br/><br/>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">SAFE</th>
<th class="head">DESTRUCTIVE</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>append</td>
<td>nconc</td>
</tr>
<tr><td>reverse</td>
<td>nreverse</td>
</tr>
<tr><td>remove</td>
<td>delete</td>
</tr>
<tr><td>remove-if</td>
<td>delete-if</td>
</tr>
<tr><td>remove-duplicates</td>
<td>delete-duplicates</td>
</tr>
<tr><td>subst</td>
<td>nsubst</td>
</tr>
<tr><td>subst-if</td>
<td>nsubst-if</td>
</tr>
<tr><td>union</td>
<td>nunion</td>
</tr>
<tr><td>intersection</td>
<td>nintersection</td>
</tr>
<tr><td>set-difference</td>
<td>nset-difference</td>
</tr>
</tbody>
</table>
当你知道修改一个列表是安全的时候，你可以使用 <em>delete</em> 替换 <em>remove</em> 、 <em>nreverse</em> 替换 <em>reverse</em> 等等。<br/><br/>
即便你想完全摆脱构造，你也不必放弃在运行中 (on the fly) 创建对象的可能性。
你需要做的是避免在运行中为它们分配空间和通过垃圾回收收回空间。通用方案是你自己预先分配内存块
(block of memory)，以及明确回收用过的块。 <em>预先</em> 可能意味着在编译期或者某些初始化例程 (routine) 中。
具体情况还应具体分析 (When speed begins to matter depends on the application)。<br/><br/>
例如，当情况允许我们利用一个有限大小的堆栈时，我们可以让堆栈在一个已经分配了空间的向量中增长或缩减，而不是构造
它。Common Lisp 内建支持把向量作为堆栈使用。如果我们传给 <em>make-array</em> 可选的 <em>fill-pointer</em> 参数，
我们将得到一个看起来可扩展 (expendable) 的向量。 <em>make-array</em> 的第一个参数指定了分配给向量的存储量，而
<em>fill-pointer</em> 指定了初始有效长度：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 333)<br/><br/>
Unexpected indentation.

&gt; (setf *print-array* t)
T
&gt; (setf vec (make-array 10 :fill-pointer 2
                           :initial-element nil))
#(NIL NIL)
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 338)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
我们刚刚制造的向量对于操作序列的函数 (sequence function) 来说仍好像只含有两个元素，<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 340)<br/><br/>
Unexpected indentation.

&gt; (length vec)
2
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 342)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
但它能够增长直到十个元素。因为 <em>vec</em> 有一个填充指针 (fill pointer)，我们可以使用 <em>vector-push</em> 和 <em>vector-pop</em>
函数推入和弹出元素，就像它是一个列表一样：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 345)<br/><br/>
Unexpected indentation.

&gt; (vector-push 'a vec)
2
&gt; vec
#(NIL NIL A)
&gt; (vector-pop vec)
A
&gt; vec
#(NIL NIL)
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 353)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
当我们调用 <em>vector-push</em> 时，它增加填充指针并返回它过去的值。只要填充指针小于 <em>make-array</em> 的第一个参数，我们
就可以向这个向量中压入 (push) 新元素；当空间用尽时， <em>vector-push</em> 返回 <em>nil</em> 。目前我们还可以向 <em>vec</em> 中
压入八个元素。<br/><br/>
使用带有填充指针的向量有一个缺点，就是它们不再是简单向量 (simple vector)。我们不得不使用 <em>aref</em> 来代替 <em>svref</em>
引用元素。代价需要和潜在的收益保持平衡。<br/><br/>

(defconstant dict (make-array 25000 :fill-pointer 0))

(defun read-words (from)
  (setf (fill-pointer dict) 0)
  (with-open-file (in from :direction :input)
    (do ((w (read-line in nil :eof)
            (read-line in nil :eof)))
        ((eql w :eof))
      (vector-push w dict))))

(defun xform (fn seq) (map-into seq fn seq))

(defun write-words (to)
  (with-open-file (out to :direction :output
                          :if-exists :supersede)
    (map nil #'(lambda (x)
                 (fresh-line out)
                 (princ x out))
             (xform #'nreverse
                    (sort (xform #'nreverse dict)
                          #'string&lt;)))))
</pre>
<strong>图 13.3 生成同韵字辞典</strong><br/><br/>
当应用 (applications) 涉及很长的序列时，你可以用 <em>map-into</em> 代替 <em>map</em> 。 <em>map-into</em> 的第一个参数不是一个序列类型
而是实际的序列，用来存储结果。这个序列可以是该函数接受的其他序列参数中的任何一个。所以，打个比方，如果你想为一个向量
的每个元素加1，你可以这么写：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 390)<br/><br/>
Unexpected indentation.

(setf v (map-into v #'1+ v))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 391)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
图 13.3 展示了一个使用大向量 (large vector) 应用的例子：一个生成简单的同韵字辞典 (或者更确切的说，一个不完全韵辞典)
的程序。函数 <em>read-line</em> 从一个每行仅含有一个单词的文件中读取单词，而函数 <em>write-words</em> 将它们按照字母的逆序打印出来。
比如，输出的起始可能是<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 395)<br/><br/>
Unexpected indentation.

a amoeba alba samba marimba...
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 396)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
结束是<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 398)<br/><br/>
Unexpected indentation.

...megahertz gigahertz jazz buzz fuzz
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 399)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
利用填充指针和 <em>map-into</em> ，我们可以把程序写的既简单又高效。<br/><br/>
在数值应用中要当心大数 (bignums)。 大数运算需要构造，因此也就会比较慢。但即便你的程序在最后必须返回大数，你也可以通过让
中间结果保持为定长数的安排来使它更高效。另一个避免垃圾回收的方法是鼓励编译器在栈上分配对象而不是在堆上。
如果你知道只是临时需要某个东西，你可以通过将它声明为 <em>dynamic extent</em> 来避免在堆上分配空间。<br/><br/>
通过将一个变量声明为动态范围 (dynamic extent) 的，你告诉编译器变量的值应该和变量保持相同的生命期。什么时候值的生命期比
变量长呢？这里有个例子：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 408)<br/><br/>
Unexpected indentation.

(defun our-reverse (lst)
  (let ((rev nil))
    (dolist (x lst)
      (push x rev))
    rev))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 413)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
在 <em>our-reverse</em> 中，作为参数传入的列表以逆序被收集到 <em>rev</em> 中。当函数返回时，变量 <em>rev</em> 将不复存在。然而，它的值 --
逆序的列表 -- 将继续存活：它被送回调用函数 (calling function)，一个知道它的命运何去何从的地方。<br/><br/>
相比之下，考虑如下 <em>adjoin</em> 实现：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 418)<br/><br/>
Unexpected indentation.

(defun our-adjoin (obj lst &amp;rest args)
  (if (apply #'member obj lst args)
      lst
      (cons obj lst)))
</pre>
在这个例子中，我们可以从函数的定义看出 <em>args</em> 参数中的值 (列表) 哪儿也没去。它不必比存储它的变量活的更久。
在这种情形下把它声明为动态范围的就比较有意义。如果我们加上这样的声明：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 426)<br/><br/>
Unexpected indentation.

(defun our-adjoin (obj lst &amp;rest args)
  (declare (dynamic-extent args))
  (if (apply #'member obj lst args)
      lst
      (cons obj lst)))
</pre>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 431)<br/><br/>
Literal block ends without a blank line; unexpected unindent.
那么编译器就可以 (但不是必须) 在栈上为 <em>args</em> 分配空间，在 <em>our-adjoin</em> 返回后它将会被自动释放。<br/><br/>


<h1>13.5 示例: 存储池 (Example: Pools)</h1>
对于涉及数据结构 (data structure) 的应用，你可以通过在一个存储池 (pool) 中预先分配一定数量的结构来避免动态分配。
当你需要一个结构时，你从池中取得一份，当你用完后，再把它送回池中。为了演示存储池的使用，我们将快速的编写一段记录港
口中船舶数量的程序原型 (prototype of a program)，然后用存储池的方式重写它。<br/><br/>

(defparameter *harbor* nil)

(defstruct ship
  name flag tons)

(defun enter (n f d)
  (push (make-ship :name n :flag f :tons d)
        *harbor*))

(defun find-ship (n)
  (find n *harbor* :key #'ship-name))

(defun leave (n)
  (setf *harbor*
        (delete (find-ship n) *harbor*)))
</pre>
<strong>图 13.4 港口</strong><br/><br/>
图 13.4 中展示的是第一个版本。 全局变量 <strong>harbor</strong> 是一个船只的列表， 每一艘船只由一个 <em>ship</em> 结构表示。 函数 <em>enter</em>
在船只进入港口时被调用； <em>find-ship</em> 根据给定名字 (如果有的话) 来寻找对应的船只；最后， <em>leave</em> 在船只离开港口时被调用。<br/><br/>
一个程序的初始版本这么写棒呆了 (a perfectly good way)，但它会产生许多的垃圾。当这个程序运行时，它会在两个方面构造：当
船只进入港口时，新的结构将会被分配；而 <strong>harbor</strong> 的每一次增大都需要使用构造。<br/><br/>
我们可以通过在编译期分配空间来消除这两种构造的源 (sources of consing)。图 13.5 展示了程序的第二个版本，它根本不会构造。<br/><br/>

(defconstant pool (make-array 1000 :fill-pointer t))

(dotimes (i 1000)
  (setf (aref pool i) (make-ship)))

(defconstant harbor (make-hash-table :size 1100
                                     :test #'eq))

(defun enter (n f d)
  (let ((s (if (plusp (length pool))
               (vector-pop pool)
               (make-ship))))
    (setf (ship-name s)        n
          (ship-flag s)        f
          (ship-tons s)        d
          (gethash n harbor) s)))

(defun find-ship (n) (gethash n harbor))

(defun leave (n)
  (let ((s (gethash n harbor)))
    (remhash n harbor)
    (vector-push s pool)))
</pre>
<strong>图 13.5 港口（第二版）</strong><br/><br/>
严格说来，新的版本仍然会构造，只是不在运行期。在第二个版本中， <em>harbor</em> 从列表变成了哈希表，所以它所有的空间都在编译期分配了。
一千个 <em>ship</em> 结构体也会在编译期被创建出来，并被保存在向量池 (vector pool) 中。(如果 <em>:fill-pointer</em> 参数为 <em>t</em> ，
填充指针将指向向量的末尾。) 此时，当 <em>enter</em> 需要一个新的结构时，它只需从池中取来一个便是，不用再调用 <em>make-ship</em> 。
而且当 <em>leave</em> 从 <em>harbor</em> 中移除一艘 <em>ship</em> 时，它把它送回池中而不是抛弃它。<br/><br/>
我们使用存储池的行为实际上是肩负起内存管理的工作。这是否会让我们的程序更快仍取决于我们的 Lisp 实现怎样管理内存。总的说来，
只有在那些仍使用着原始垃圾回收器的实现中，或者在那些对 GC 的不可预见性比较敏感的实时应用中才值得一试。<br/><br/>


<h1>13.6 快速操作符 (Fast Operators)</h1>
本章一开始就宣称 Lisp 是两种不同的语言。就某种意义来讲这确实是正确的。如果你仔细看过 Common Lisp 的设计，你会发现某些特性主要是为了速度，而另外一些主要为了便捷性。<br/><br/>
例如，你可以通过三个不同的函数取得向量给定位置上的元素： <em>elt</em> 、 <em>aref</em> 、 <em>svref</em> 。如此的多样性允许你把一个程序
的性能提升到极致 (allow you to squeeze as much performance out of a program as possible)。 所以如果你可以
使用 <em>svref</em> ，完事儿！ 相反，如果对某段程序来说速度很重要的话，或许不应该调用 <em>elt</em> ，它既可以用于数组也可以用于列表。<br/><br/>
对于列表来说，你应该调用 <em>nth</em> ，而不是 <em>elt</em> 。然而只有单一的一个函数 -- <em>length</em> -- 用于计算任何一个序列的长度。
为什么 Common Lisp 不单独为列表提供一个特定的版本呢？因为如果你的程序正在计算一个列表的长度，它在速度上已经输了。在这个
例子中，就像许多其他的例子一样，语言的设计暗示了哪些会是快速的而哪些不是。<br/><br/>
另一对相似的函数是 <em>eql</em> 和 <em>eq</em> 。前者是验证同一性 (identity) 的默认断言 (predicate) ，但如果你知道参数不会是
字符或者数字时，使用后者其实更快。两个对象 <em>eq</em> 只有当它们处在相同的内存位置上时才成立。数字和字符可能不会与任何特定的内存
位置相关，因此 <em>eq</em> 不适用于它们 (即便多数实现中它仍然能用于定长数)。对于其他任何种类的参数， <em>eq</em> 和 <em>eql</em> 将返回相同的值。<br/><br/>
使用 <em>eq</em> 来比较对象总是最快的，因为 Lisp 所需要比较的仅仅是指向对象的指针。因此 <em>eq</em> 哈希表 (如图 13.5 所示) 应该
会提供最快的访问 (access)。 在一个 <em>eq</em> 哈希表中， <em>gethash</em> 可以只根据指针查找，甚至不需要查看它们指向的是什么。
然而，访问不是唯一要考虑的因素； <em>eq</em> 和 <em>eql</em> 哈希表在拷贝型垃圾回收算法 (copying garbage collection algorithm)
中会引起额外的开销，因为垃圾回收后需要对一些哈希值重新进行计算 (rehashing)。
如果这变成了一个问题，最好的解决方案是使用一个把定长数作为键值的 <em>eql</em> 哈希表。<br/><br/>
当被调函数有一个余留参数 (rest parameter) 时，调用 <em>reduce</em> 可能是比 <em>apply</em> 更高效的一种方式。例如，相比<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 528)<br/><br/>
Unexpected indentation.

(apply #'+ '(1 2 3))
</pre>
写成如下可以更高效：<br/><br/>

System Message: ERROR/3 (<tt class="docutils">../acl-chinese/zhCN/ch13-cn.rst</tt>, line 532)<br/><br/>
Unexpected indentation.

(reduce #'+ '(1 2 3))
</pre>
它不仅有助于调用正确的函数，还有助于按照正确的方式调用它们。余留 (rest)、可选 (optional) 和关键字 (keyword) 参数
是昂贵的。只使用普通 (ordinary) 参数，函数调用中的参量会被调用者简单的留在被调者能够找到的地方。但其他种类的参数涉及
运行时的处理。关键字参数是最差的。针对内建函数，优秀的编译器采用特殊的办法把使用关键字参量的调用编译成快速代码 (fast code)。
但对于你自己编写的函数，避免在程序中对速度敏感的部分使用它们只有好处没有坏处 (just as well)。另外，不把大量的参量都放到
余留参数中也是明智的举措，如果这可以避免的话。<br/><br/>
不同的编译器有时也会有一些它们独到优化。例如，有些编译器可以针对键值是一个狭小范围中的整数的 <em>case</em> 语句进行优化。
查看你的用户手册来了解那些实现特有的优化的建议吧。<br/><br/>


<h1>13.7 二阶段开发 (Two-Phase Development)</h1>
在以速度至上的应用中，你也许想要使用诸如 C 或者 汇编 这样的低级语言来重写一个 Lisp 程序的某部分。
你可以对用任何语言编写的程序使用这一技巧 -- C 程序的关键部分经常用汇编重写 -- 但语言越抽象，
用两阶段 (two phases) 开发程序的好处就越明显。<br/><br/>
Common Lisp 没有规定如何集成其他语言所编写的代码。这部分留给了实现决定，而几乎所有的实现都提供了某种方式来实现它。
使用一种语言编写程序然后用另一种语言重写它其中部分看起来可能是一种浪费。事实上，经验显示这是一种好的开发软件的方式。
先针对功能、然后是速度比试着同时达成两者来的简单。<br/><br/>
如果编程完全是一个机械的过程 -- 简单的把规格说明 (specification) 翻译为代码 -- 在一步中把所有的事情都搞定也许是合理的。
但编程永远不是如此。不论规格说明多么精确， 编程总是涉及一定量的探索 -- 通常比任何人能预期到的还多的多。<br/><br/>
一份好的规格说明也许会让编程看起来像是简单的把它们翻译成代码的过程。这是一个普遍的误区。
编程必定涉及探索，因为规格说明必定含糊不清。如果它们不含糊的话，它们就都算不上规格说明。<br/><br/>
在其他领域，尽可能精准的规格说明也许是可取的。如果你要求一块金属被切割成某种形状，最好准确的说出你想要的。但这个规则不适用于软件，
因为程序和规格说明由相同的东西构成：文本。你不可能编写出完全合意的规格说明。如果规格说明有那么精确的话，它们就变成程序了。<br/><br/>
对于存在着可观数量的探索的应用 (再一次，比任何人承认的还要多)，将实现分成两个阶段是值得的。而且在第一阶段中你所使用的手段
(medium) 不必就是最后的那个。例如，制作铜像的标准方法是先从粘土开始。你先用粘土做一个塑像出来，然后用它做一个模子，
在这个模子中铸造铜像。在最后的塑像中是没有丁点粘土的，但你可以从铜像的形状中认识到它发挥的作用。试想下从一开始就只
用一块儿铜和一个凿子来制造这么个一模一样的塑像要多难啊！出于相同的原因，首先用 Lisp 来编写程序，然后用 C 改写它
要比从头开始就用 C 编写这个程序要好。<br/><br/>


<h1>Chapter 13 总结 (Summary)</h1>
<ol class="arabic simple">
<li>优化不应开始的过早，应该关注瓶颈，而且应该从算法开始。</li>
<li>有五个不同的参数控制编译。它们可以在本地声明也可以在全局声明。</li>
<li>优秀的编译器能够优化尾调用，将一个尾递归的函数转换为一个循环。内联编译是另一种避免函数调用的方法。</li>
<li>类型声明并不是必须的，但它们可以让一个程序更高效。类型声明对于处理数值和数组的代码特别重要。</li>
<li>少的构造可以让程序更快，特别是在使用着原始的垃圾回收器的实现中。解决方案是使用解构函数、预先分配空间块、以及在栈上分配。</li>
<li>某些情况下，从预先分配的存储池中提取对象可能是有价值的。</li>
<li>Common Lisp 的某些部分是为了速度而设计的，另一些则为了灵活性。</li>
<li>编程必定存在探索的过程。探索和优化应该被分开 -- 有时甚至需要使用不同的语言。</li>
</ol>


<h1>Chapter 13 练习 (Exercises)</h1>
<ol class="arabic">
<li>检验你的编译器是否支持 (observe) 内敛声明。<br/><br/>
</li>
<li>将下述函数重写为尾递归形式。它被编译后能快多少？<br/><br/>
<dl class="docutils">
<dt>::</dt>
<dd><dl class="first last docutils">
<dt>(defun foo (x)</dt>
<dd><dl class="first last docutils">
<dt>(if (zerop x)</dt>
<dd>0
(1+ (foo (1- x)))))<br/><br/>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
注意：你需要增加额外的参数。<br/><br/>
</li>
<li>为下述程序增加声明。你能让它们变快多少？<br/><br/>
</li>
</ol>

(a) 在 5.7 节中的日期运算代码。
(b) 在 9.8 节中的光线跟踪器 (ray-tracer)。
</pre>
<ol class="arabic simple" start="4">
<li>重写 3.15 节中的广度优先搜索 (breadth-first search) 的代码让它尽可能少的使用构造。</li>
<li>使用存储池修改 4.7 节中的二叉搜索 (binary search) 的代码。</li>
</ol>
脚注<br/><br/>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>较早的实现或许不提供 <em>declaim</em> ；需要使用 <em>proclaim</em> 并且引用这些参量 (quote the argument)。</td></tr>
</tbody>
</table>
