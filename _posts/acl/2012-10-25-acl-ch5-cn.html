---
layout: post
title : "第5章--控制流"
category : acl
tags : [acl]
---
{% include JB/setup %}

2.2 节 介绍了 Common Lisp 的求值规则，直到现在你应该很熟悉了。本章的操作符都有一个共同点，就是它们都违反了求值规则。他们让你决定在程序当中何时要求值。如果普通的函数调用是 Lisp 程序的树叶的话，那这些操作符就是用来构造树枝。<br/><br/>

<h1>5.1 区块 (Blocks)</h1>
Common Lisp 有三个构造区块 (block) 的基本操作符： <tt class="docutils literal">progn</tt> , <tt class="docutils literal">block</tt> 以及 <tt class="docutils literal">tagbody</tt> 。我们已经看过 <tt class="docutils literal">progn</tt> 了。在 <tt class="docutils literal">progn</tt> 主体中的表达式会依序求值，并返回最後一个表达式的值：<br/><br/>

&gt; (progn
    (format t &quot;a&quot;)
    (format t &quot;b&quot;)
    (+ 11 12))
ab
23
</pre>
由於只返回最後一个表达式的值，代表著使用 <tt class="docutils literal">progn</tt> （或任何区块）意味着副作用。<br/><br/>
一个 <tt class="docutils literal">block</tt> 像是带有名字及紧急出口的 <tt class="docutils literal">progn</tt> 。第一个参数应为符号。这变成了区块的名字。在主体中的任何地方，你可以停止求值，并透过使用 <tt class="docutils literal"><span class="pre">return-from</span></tt> 指定区块的名字，来立即返回一个数值：<br/><br/>

&gt; (block head
    (format t &quot;Here we go.&quot;)
    (return-from head 'idea)
    (format t &quot;We'll never see this.&quot;))
Here we go.
IDEA
</pre>
调用 <tt class="docutils literal"><span class="pre">return-from</span></tt> 允许你的程序从代码的任何地方，突然但优雅地退出。第二个传给 <tt class="docutils literal"><span class="pre">return-from</span></tt> 的参数，用来作为以第一个参数为名的区块的返回值。在 <tt class="docutils literal"><span class="pre">return-from</span></tt> 之後的表达式不会被求值。<br/><br/>
也有一个 <tt class="docutils literal">return</tt> 宏，它把传入的参数当做封闭区块 <tt class="docutils literal">nil</tt> 的返回值：<br/><br/>

&gt; (block nil
    (return 27))
27
</pre>
许多接受一个表达式主体的 Common Lisp 操作符，皆被隐含在一个叫做 <tt class="docutils literal">nil</tt> 的区块里。比如，所有由 <tt class="docutils literal">do</tt> 构造的迭代函数：<br/><br/>

&gt; (dolist (x '(a b c d e))
    (format t &quot;~A &quot; x)
    (if (eql x 'c)
        (return 'done)))
A B C
DONE
</pre>
使用 <tt class="docutils literal">defun</tt> 定义的函数主体，都被隐含在一个与函数同名的区块，所以你可以：<br/><br/>

(defun foo ()
  (return-from foo 27))
</pre>
在一个显式或隐式的 <tt class="docutils literal">block</tt> 外，不论是 <tt class="docutils literal"><span class="pre">return-from</span></tt> 或 <tt class="docutils literal">return</tt> 都不会工作。<br/><br/>
使用 <tt class="docutils literal"><span class="pre">return-from</span></tt> ，我们可以写出一个更好的 <tt class="docutils literal"><span class="pre">read-integer</span></tt> 版本：<br/><br/>

(defun read-integer (str)
  (let ((accum 0))
    (dotimes (pos (length str))
      (let ((i (digit-char-p (char str pos))))
        (if i
            (setf accum (+ (* accum 10) i))
            (return-from read-integer nil))))
    accum))
</pre>
68 页的版本在构造整数之前，需要检查所有的字符。现在两个步骤可以结合，因为如果我们遇到非数字的字符时，我们可以舍弃计算结果。出现在主体的原子（atom）被解读为标签（labels)；把这样的标签传给 <tt class="docutils literal">go</tt> ，会把控制权交给标签後的表达式。以下是一个非常丑的程序片段，用来印出一至十的数字：<br/><br/>

&gt; (tagbody
    (setf x 0)
    top
      (setf x (+ x 1))
      (format t &quot;~A &quot; x)
      (if (&lt; x 10) (go top)))
1 2 3 4 5 6 7 8 9 10
NIL
</pre>
这个操作符主要用来实现其它的操作符，不是你自己会使用的东西。大多数迭代操作符都有隐含一个 <tt class="docutils literal">tagbody</tt> ，所以可能可以在主体里（虽然很少想要）使用标签及 <tt class="docutils literal">go</tt> 。<br/><br/>
你如何决定要使用哪一个区块建构子（block construct）？几乎任何时候，你会使用 <tt class="docutils literal">progn</tt> 。如果你想要突然退出的话，使用 <tt class="docutils literal">block</tt> 来取代。多数程序员永远不会显式地使用 <tt class="docutils literal">tagbody</tt> 。<br/><br/>


<h1>5.2 语境 (Context)</h1>
另一个我们用来替表达式分组的操作符是 <tt class="docutils literal">let</tt> 。它接受一个代码主体，但允许我们在主体内设置新变量：<br/><br/>

&gt; (let ((x 7)
        (y 2))
    (format t &quot;Number&quot;)
    (+ x y))
</pre>
一个像是 <tt class="docutils literal">let</tt> 的操作符创造出一个新的词法语境（lexical context）。在这个语境里有两个新变量，然而在外部语境的变量也因此变得不可视了。<br/><br/>
概念上说，一个 <tt class="docutils literal">let</tt> 表达式像是一个函数调用。在 2.14 节证明过，可以用名字来参照一个函数，也可以从字面上藉由使用一个 lambda 表达式来参照。由於一个 lambda 表达式像是函数的名字，我们可以像使用函数名那样，把 lambda 表达式作为函数调用的第一个参数：<br/><br/>

&gt; ((lambda (x) (+ x 1)) 3)
4
</pre>
前述的 <tt class="docutils literal">let</tt> 表达式实际上等同於：<br/><br/>

((lambda (x y)
   (format t &quot;Number&quot;)
   (+ x y))
 7
 20)
</pre>
有关 <tt class="docutils literal">let</tt> 的任何问题，应该是如何把责任交给 <tt class="docutils literal">lambda</tt> ，因为进入一个 <tt class="docutils literal">let</tt> 如同於执行一个函数调用。<br/><br/>
这个模型清楚的告诉我们，由 <tt class="docutils literal">let</tt> 创造的变量的值，不能依赖其它由同一个 <tt class="docutils literal">let</tt> 所创造的变量。举例来说，如果我们试着：<br/><br/>

(let ((x 2)
      (y (+ x 1)))
  (+ x y))
</pre>
在 <tt class="docutils literal">(+ x 1)</tt> 中的 <tt class="docutils literal">x</tt> 不是前一行所设置的值，因为整个表达式等同於：<br/><br/>

((lambda (x y) (+ x y)) 2
                        (+ x 1))
</pre>
这里明显看到 <tt class="docutils literal">(+ x 1)</tt> 作为参数传给函数，不能参照函数内的参数 <tt class="docutils literal">x</tt> 。<br/><br/>
所以如果你真的想要新的变量的值，依赖由同一个表达式所设立的另一个变量？在这个情况，你会使用一个变形版本 <tt class="docutils literal">let*</tt> ：<br/><br/>

&gt; (let* ((x 1)
         (y (+ x 1)))
    (+ x y))
3
</pre>
一个 <tt class="docutils literal">let*</tt> 功能上等同於一系列嵌套的 <tt class="docutils literal">let</tt> 。这个特别的例子等同於：<br/><br/>

(let ((x 1))
  (let ((y (+ x 1)))
    (+ x y)))
</pre>
<tt class="docutils literal">let</tt> 与 <tt class="docutils literal">let*</tt> 将变量初始值都设为 <tt class="docutils literal">nil</tt> 。这样的变量不需要依附在列表内:<br/><br/>

&gt; (let (x y)
    (list x y))
(NIL NIL)
</pre>
<tt class="docutils literal"><span class="pre">destructuring-bind</span></tt> 宏是通用化的 <tt class="docutils literal">let</tt> 。与其接受单一变量，它接受一个模式 (pattern) –– 一个或多个变量所形成的树 –– 并将它们与某个实际的树所对应的部份做绑定。举例来说：<br/><br/>

&gt; (destructuring-bind (w (x y) . z) '(a (b c) d e)
    (list w x y z))
(A B C (D E))
</pre>
若给定的树（第二个参数）没有匹配模式（第一个参数）时，会产生错误。<br/><br/>


<h1>5.3 条件 (Conditionals)</h1>
最简单的条件式是 <tt class="docutils literal">if</tt> ；其馀的条件式都是基於 <tt class="docutils literal">if</tt> 所构造的。第二简单的条件式是 <tt class="docutils literal">when</tt> ，它接受一个测试表达式 (test expression)与一个代码主体。若测试表达式求值返回真时，则对主体求值。所以<br/><br/>

(when (oddp that)
  (format t &quot;Hmm, that's odd.&quot;)
  (+ that 1))
</pre>
等效於<br/><br/>

(if (oddp that)
    (progn
      (format t &quot;Hmm, that's odd.&quot;)
      (+ that 1)))
</pre>
<tt class="docutils literal">when</tt> 的相反是 <tt class="docutils literal">unless</tt> ；它接受同样的参数，但主体仅在测试表达式返回假时，才对主体求值。<br/><br/>
所有条件式的母体 (从正反两面看) 是 <tt class="docutils literal">cond</tt> ，它带有两个新的优点：它允许多重条件式，与每个条件式相关的代码是隐式的 <tt class="docutils literal">progn</tt> 。它预期在我们需要在一个 <tt class="docutils literal">if</tt> 中使用另一个 <tt class="docutils literal">if</tt> 的情况下使用。 举例来说，这个伪 member 函数<br/><br/>

(defun our-member (obj lst)
  (if (atom lst)
      nil
      (if (eql (car lst) obj)
          lst
          (our-member obj (cdr lst)))))
</pre>
也可以定义成：<br/><br/>

(defun our-member (obj lst)
  (cond ((atom lst) nil)
        ((eql (car lst) obj) lst)
        (t (our-member obj (cdr lst)))))
</pre>
事实上，Common Lisp 的实现大概会把 <tt class="docutils literal">cond</tt> 翻译成 <tt class="docutils literal">if</tt> 的形式。<br/><br/>
总得来说呢， <tt class="docutils literal">cond</tt> 接受零个或多个参数。每一个参数必须是一个具有条件式伴随着零个或多个表达式的列表。当 <tt class="docutils literal">cond</tt> 表达式被求值时，测试条件式依序求值，直到某个测试条件式返回真才停止。当返回真时，与其关联的表达式会被依序求值，而最後一个返回的数值会作为 <tt class="docutils literal">cond</tt> 的返回值。如果符合的条件式之後没有表达式的话：<br/><br/>

&gt; (cond (99))
99
</pre>
则会返回条件式的值。<br/><br/>
由於 <tt class="docutils literal">cond</tt> 子句的 <tt class="docutils literal">t</tt> 条件永远成立，通常我们把它放在最後，作为缺省的条件式。如果没有子句符合时，则 <tt class="docutils literal">cond</tt> 返回 <tt class="docutils literal">nil</tt> ，但利用 <tt class="docutils literal">nil</tt> 返回值是一种很差的风格 (这种问题可能发生的例子，请看 292 页)。译注: <strong>Appendix A, unexpected nil</strong> 小节。<br/><br/>
当你想要把一个数值与一系列的常量比较时，有 <tt class="docutils literal">case</tt> 可以用。我们可以使用 <tt class="docutils literal">case</tt> 来定义一个函数，返回每个月份中的天数：<br/><br/>

(defun month-length (mon)
  (case mon
    ((jan mar may jul aug oct dec) 31)
    ((apr jun sept nov) 30)
    (feb (if (leap-year) 29 28))
    (otherwise &quot;unknown month&quot;)))
</pre>
一个 <tt class="docutils literal">case</tt> 表达式由一个参数开始，此参数会被拿来与每个子句的键值做比较。接着是零个或多个子句，每个子句由一个或一串键值开始，跟随着零个或多个表达式。键值被视为常量；它们不会被求值。第一个参数的值被拿来与子句中的键值做比较 (使用 <tt class="docutils literal">eql</tt> )。如果匹配时，子句剩馀的表达式会被求值，并将最後一个求值作为 <tt class="docutils literal">case</tt> 的返回值。<br/><br/>
缺省子句的键值可以是 <tt class="docutils literal">t</tt> 或 <tt class="docutils literal">otherwise</tt> 。如果没有子句符合时，或是子句只包含键值时，<br/><br/>

&gt; (case 99 (99))
NIL
</pre>
则 <tt class="docutils literal">case</tt> 返回 <tt class="docutils literal">nil</tt> 。<br/><br/>
<tt class="docutils literal">typecase</tt> 宏与 <tt class="docutils literal">case</tt> 相似，除了每个子句中的键值应为型别修饰符 (type specifiers)，以及第一个参数与键值比较的函数使用 <tt class="docutils literal">typep</tt> 而不是 <tt class="docutils literal">eql</tt> (一个 <tt class="docutils literal">typecase</tt> 的例子在 107 页)。 译注: 6.5 小节。<br/><br/>


<h1>5.4 迭代 (Iteration)</h1>
最基本的迭代操作符是 <tt class="docutils literal">do</tt> ，它在 2.13 节介绍过。由於 <tt class="docutils literal">do</tt> 包含了隐式的 <tt class="docutils literal">block</tt> 及 <tt class="docutils literal">tagbody</tt> ，我们现在知道是可以在 <tt class="docutils literal">do</tt> 主体内使用 <tt class="docutils literal">return</tt> , <tt class="docutils literal"><span class="pre">return-from</span></tt> 以及 <tt class="docutils literal">go</tt> 。<br/><br/>
2.13 节提到 <tt class="docutils literal">do</tt> 的第一个参数必须是一个变量规格说明的列表，每个可以是如下形式：<br/><br/>

(variable  initial  update)
</pre>
<tt class="docutils literal">initial</tt> 与 <tt class="docutils literal">update</tt> 形式是选择性的。若 <tt class="docutils literal">update</tt> 形式忽略时，每次迭代时不会更新变量。若 <tt class="docutils literal">initial</tt> 形式也忽略时，变量会使用 <tt class="docutils literal">nil</tt> 来初始化。<br/><br/>
在 23 页的例子中（译注: 2.13 节），<br/><br/>

(defun show-squares (start end)
   (do ((i start (+ i 1)))
       ((&gt; i end) 'done)
     (format t &quot;~A ~A~%&quot; i (* i i))))
</pre>
<tt class="docutils literal">update</tt> 形式参照到由 <tt class="docutils literal">do</tt> 所创造的变量。一般都是这么用。如果一个 <tt class="docutils literal">do</tt> 的 <tt class="docutils literal">update</tt> 形式，没有至少参照到一个自己创造的变量时，反而很奇怪。<br/><br/>
当超过一个变量被更新时，问题来了，如果一个 <tt class="docutils literal">update</tt> 形式，参照到一个拥有自己的 <tt class="docutils literal">update</tt> 形式的变量时，它会被更新呢或是获得前一次迭代的值？使用 <tt class="docutils literal">do</tt> 的话，它获得後者的值：<br/><br/>

&gt; (let ((x 'a))
    (do ((x 1 (+ x 1))
         (y x x))
        ((&gt; x 5))
      (format t &quot;(~A ~A)  &quot; x y)))
(1 A)  (2 1)  (3 2)  (4 3)  (5 4)
NIL
</pre>
每一次迭代时， <tt class="docutils literal">x</tt> 获得先前的值加一； <tt class="docutils literal">y</tt> 也获得 <tt class="docutils literal">x</tt> 的前一次数值。<br/><br/>
但也有一个 <tt class="docutils literal">do*</tt> ，它有着 <tt class="docutils literal">let</tt> 与 <tt class="docutils literal">let*</tt> 同样的关系。任何 <tt class="docutils literal">initial</tt> 或 <tt class="docutils literal">update</tt> 形式可以参照到前一个子句的变量，并会获得当下的值：<br/><br/>

&gt; (do* ((x 1 (+ x 1))
      (y x x))
     ((&gt; x 5))
  (format t &quot;(~A ~A) &quot; x y))
(1 1) (2 2) (3 3) (4 4) (5 5)
NIL
</pre>
除了 <tt class="docutils literal">do</tt> 与 <tt class="docutils literal">do*</tt> 之外，也有几个特别用途的迭代操作符。要迭代一个列表的元素，我们可以使用 <tt class="docutils literal">dolist</tt> :<br/><br/>

&gt; (dolist (x '(a b c d) 'done)
    (format t &quot;~A &quot; x))
A B C D
DONE
</pre>
当迭代结束时，初始列表内的第三个元素 (译注: <tt class="docutils literal">done</tt> ) ，会被求值并作为 <tt class="docutils literal">dolist</tt> 的返回值。缺省是 <tt class="docutils literal">nil</tt> 。<br/><br/>
有着同样的精神的是 <tt class="docutils literal">dotimes</tt> ，给定某个 <tt class="docutils literal">n</tt> ，从整数 <tt class="docutils literal">0</tt> 迭代至 <tt class="docutils literal"><span class="pre">n-1</span></tt> :<br/><br/>

(dotimes (x 5 x)
  (format t &quot;~A &quot; x))
0 1 2 3 4
5
</pre>
使用 <tt class="docutils literal">dolist</tt> ，初始列表内的第三个元素是选择性的，缺省是 <tt class="docutils literal">nil</tt> 。注意它可以参照到迭代里的变量。<br/><br/>

do 的重点 (THE POINT OF do)

在 “The Evolution of Lisp” 里，Steele 与 Garbriel 陈述了 do 的重点，
表达的实在太好了，值得整个在这里引用过来：

撇开争论语法不谈，有件事要说明的是，在任何一个编程语言中，一个循环若一次只能更新一个变量是毫无用处的。
几乎在任何情况下，会有一个变量用来产生下个值，而另一个变量用来累积结果。如果循环语法只能产生变量，
那么累积结果就得藉由赋值语句来“手动”实现…或有其他的副作用。具有多变量的 do 循环，体现了产生与累积的
本质对称性，允许可以没有副作用地表达迭代过程：

(defun factorial (n)
  (do ((j n (- j 1))
       (f 1 (* j f)))
    ((= j 0) f)))

当然在 step 形式里实现所有的实际工作，一个没有主体的 do 循环形式是较不寻常的。
</pre>
函数 <tt class="docutils literal">mapc</tt> 和 <tt class="docutils literal">mapcar</tt> 很像，但不会 <tt class="docutils literal">cons</tt> 一个新列表作为返回值，所以使用它的唯一原因是为了副作用。它比 <tt class="docutils literal">dolist</tt> 来得灵活，因为它可以同时遍历多个列表：<br/><br/>

&gt; (mapc #'(lambda (x y)
          (format t &quot;~A ~A  &quot; x y))
      '(hip flip slip)
      '(hop flop slop))
HIP HOP  FLIP FLOP  SLIP SLOP
(HIP FLIP SLIP)
</pre>
它总是返回第二个参数。<br/><br/>


<h1>5.5 多值 (Multiple Values)</h1>
曾有人这么说，为了要强调函数式编程的重要性，每个 Lisp 表达式都返回一个值。现在事情不是这么简单了；在 Common Lisp 里，一个表达式可以返回零个或多个数值。最多可以返回几个值取决於各家实现，但至少可以返回 19 个值。<br/><br/>
多值允许一个函数计算多件事情来返回它们，而不用构造一个包含它们的结构。举例来说，内建的 <tt class="docutils literal"><span class="pre">get-decoded-time</span></tt> 返回 9 个数值来表示现在的时间：秒，分，时，日期，月，天以及另外两个。<br/><br/>
多值也让查询函数可以分辨出 <tt class="docutils literal">nil</tt> 及查询失败的情况。这也是为什么 <tt class="docutils literal">gethash</tt> 返回两个值。因为它使用第二个数值来指出成功或失败，我们可以在哈希表里储存 <tt class="docutils literal">nil</tt> ，就像我们可以储存别的数值那样。<br/><br/>
<tt class="docutils literal">values</tt> 函数返回多个数值。它一个不少地返回你作为数值所传入的参数：<br/><br/>

&gt; (values 'a nil (+ 2 4))
A
NIL
6
</pre>
如果一个 <tt class="docutils literal">values</tt> 表达式是函数主体最後求值的表达式，它所返回的数值变成函数的返回值。多值可以原封不地透过任何数量的返回来传递：<br/><br/>

&gt; ((lambda () ((lambda () (values 1 2)))))
1
2
</pre>
然而若只预期一个返回值时，第一个之外的值会被舍弃：<br/><br/>

&gt; (let ((x (values 1 2)))
    x)
1
</pre>
藉由不带参数使用 <tt class="docutils literal">values</tt> ，是可能不返回值的。在这个情况下，预期一个返回值的话，会获得 <tt class="docutils literal">nil</tt> :<br/><br/>

&gt; (values)
&gt; (let ((x (values)))
    x)
NIL
</pre>
要接收多个数值，我们使用 <tt class="docutils literal"><span class="pre">multiple-value-bind</span></tt> :<br/><br/>

&gt; (multiple-value-bind (x y z) (values 1 2 3)
    (list x y z))
(1 2 3)

&gt; (multiple-value-bind (x y z) (values 1 2)
    (list x y z))
(1 2 NIL)
</pre>
如果变量的数量大於数值的数量，剩馀的变量会是 <tt class="docutils literal">nil</tt> 。如果数值的数量大於变量的数量，多馀的值会被舍弃。所以只想印出时间我们可以这么写:<br/><br/>

&gt; (multiple-value-bind (s m h) (get-decoded-time)
    (format t &quot;~A:~A:~A&quot; h m s))
&quot;4:32:13&quot;
</pre>
你可以藉由 <tt class="docutils literal"><span class="pre">multiple-value-call</span></tt> 将多值作为参数传递到第二个函数：<br/><br/>

&gt; (multiple-value-call #'+ (values 1 2 3))
6
</pre>
也有一个函数是 <tt class="docutils literal"><span class="pre">multiple-value-list</span></tt> :<br/><br/>

&gt; (multiple-value-list (values 'a 'b 'c))
(A B C)
</pre>
看起来像是使用 <tt class="docutils literal">#'list</tt> 作为第一个参数的来调用 <tt class="docutils literal"><span class="pre">multiple-value-call</span></tt> 。<br/><br/>


<h1>5.6 中止 (Aborts)</h1>
你可以使用 <tt class="docutils literal">return</tt> 在任何时候离开一个 <tt class="docutils literal">block</tt> 。有时候我们想要做更极端的事，在数个函数调用中将控制权转移回来。要达成这件事我们使用 <tt class="docutils literal">catch</tt> 与 <tt class="docutils literal">throw</tt> 。一个 <tt class="docutils literal">catch</tt> 表达式接受一个标签 (tag)，标签可以是任何种类的对象，伴随着一个表达式主体：<br/><br/>

(defun super ()
  (catch 'abort
    (sub)
    (format t &quot;We'll never see this.&quot;)))

(defun sub ()
  (throw 'abort 99))
</pre>
表达式依序求值，就像它们是在 <tt class="docutils literal">progn</tt> 里一样。在这段代码里的任何地方，一个带有特定标签的 <tt class="docutils literal">throw</tt> 会导致 <tt class="docutils literal">catch</tt> 表达式直接返回：<br/><br/>

&gt; (super)
99
</pre>
一个带有给定标签的 <tt class="docutils literal">throw</tt> ，为了要到达匹配标签的 <tt class="docutils literal">catch</tt> ，会将控制权转移 (因此杀掉进程)给任何有别的标签的 <tt class="docutils literal">catch</tt> 。如果没有一个 <tt class="docutils literal">catch</tt> 符合欲匹配的标签时， <tt class="docutils literal">throw</tt> 会产生一个错误。<br/><br/>
调用 <tt class="docutils literal">error</tt> 同时中断了执行，本来会将控制权转移到调用树 (calling tree)的更高点，取而代之的是它将控制权转移给 Lisp 错误处理器 (error handler)。通常会导致调用一个中断循环 (break loop)。以下是一个假设的 Common Lisp 实现可能会发生的事情：<br/><br/>

&gt; (progn
    (error &quot;Oops!&quot;)
    (format t &quot;After the error.&quot;))
Error: Oops!
       Options: :abort, :backtrace
&gt;&gt;
</pre>
译注：2 个 <tt class="docutils literal">&gt;&gt;</tt> 显示出我们进入中断循环了。<br/><br/>
关於错误与状态的更多讯息，参见 14.6 小节及附录A。<br/><br/>
有时候你想要代码防止被 <tt class="docutils literal">throw</tt> 与 <tt class="docutils literal">error</tt> 打断。藉由使用 <tt class="docutils literal"><span class="pre">unwind-protect</span></tt> ，你可以确保像是前述的中断不会让你的程序停在一个不一致的状态。一个 <tt class="docutils literal"><span class="pre">unwind-protect</span></tt> 接受任何数量的参数并返回第一个参数的值。然而即便是第一个参数的求值被打断时，剩下的表达式仍会被求值：<br/><br/>

&gt; (setf x 1)
1
&gt; (catch 'abort
    (unwind-protect
      (throw 'abort 99)
      (setf x 2)))
99
&gt; x
2
</pre>
在这里，即便 <tt class="docutils literal">throw</tt> 将控制权交回监测的 <tt class="docutils literal">catch</tt> ， <tt class="docutils literal"><span class="pre">unwind-protect</span></tt> 确保控制权移交时，第二个表达式有被求值。无论何时，一个确切的动作要伴随着某种清理或重置时， <tt class="docutils literal"><span class="pre">unwind-protect</span></tt> 可能会是有用的。在 121 页提到了一个例子。<br/><br/>


<h1>5.7 示例：日期运算 (Example: Date Arithmetic)</h1>
在某些应用里，能够做日期的加减是很有用的––举例来说，能够算出从 1997 年 12 月 17 日，六十天之後是 1998 年 2 月 15 日。在这个小节里，我们会编写一个实用的工具来做日期运算。我们会将日期转成整数，起始点设置在 2000 年 1 月 1 日。我们会使用内建的 <tt class="docutils literal">+</tt> 与 <tt class="docutils literal">-</tt> 函数来处理这些数字，而当我们转换完毕时，将结果转回一个日期。<br/><br/>
要将日期转成数字，我们需要从日期的单位中，算出总天数有多少。举例来说，2004 年 11 月 13 日的天数总和，是从起始点至 2004 年有多少天，加上从 2004 年到 2004 年 11 月有多少天，再加上 13 天。<br/><br/>
有一个我们需要的东西是，一张列出非润年每月份有多少天的表格。我们可以使用 Lisp 来推出这个表格的内容。我们从列出每月份的长度开始：<br/><br/>

&gt; (setf mon '(31 28 31 30 31 30 31 31 30 31 30 31))
(31 28 31 30 31 30 31 31 30 31 30 31)
</pre>
我们可以藉由套用 <tt class="docutils literal">+</tt> 函数至这个列表来测试总长度：<br/><br/>

&gt; (apply #'+ mon)
365
</pre>
现在如果我们反转这个列表并使用 <tt class="docutils literal">maplist</tt> 来应用 <tt class="docutils literal">+</tt> 函数至每下一个 <tt class="docutils literal">cdr</tt> 上，我们可以获得从每个月份开始所累积的天数：<br/><br/>

&gt; (setf nom (reverse mon))
(31 30 31 30 31 31 30 31 30 31 28 31)
&gt; (setf sums (maplist #'(lambda (x)
                          (apply #'+ x))
                      nom))
(365 334 304 273 243 212 181 151 120 90 59 31)
</pre>
这些数字体现了从二月一号开始已经过了 31 天，从三月一号开始已经过了 59 天…等等。<br/><br/>
我们刚刚建立的这个列表，可以转换成一个向量，见图 5.1，它包含了转换日期至整数的代码。<br/><br/>

(defconstant month
  #(0 31 59 90 120 151 181 212 243 273 304 334 365))

(defconstant yzero 2000)

(defun leap? (y)
  (and (zerop (mod y 4))
       (or (zerop (mod y 400))
           (not (zerop (mod y 100))))))

(defun date-&gt;num (d m y)
  (+ (- d 1) (month-num m y) (year-num y)))

(defun month-num (m y)
  (+ (svref month (- m 1))
     (if (and (&gt; m 2) (leap? y)) 1 0)))

(defun year-num (y)
  (let ((d 0))
    (if (&gt;= y yzero)
        (dotimes (i (- y yzero) d)
          (incf d (year-days (+ yzero i))))
        (dotimes (i (- yzero y) (- d))
          (incf d (year-days (+ y i)))))))

(defun year-days (y) (if (leap? y) 366 365))
</pre>
<strong>图 5.1 日期运算：转换日期至数字</strong><br/><br/>
一个典型 Lisp 程序的生命周期有四个阶段：先写好，然後读入，接着编译，最後执行。有件 Lisp 非常独特的事情之一是，在这四个阶段时， Lisp 一直都在那里。你可以在你的程序编译 (参见 10.2 小节)或读入时 (参见 14.3 小节) 来调用 Lisp。我们推导出 <tt class="docutils literal">month</tt> 的方法演示了，你如何在撰写一个程序时使用 Lisp。<br/><br/>
效率通常只跟第四个阶段有关系，执行期 (run-time)。在前三个阶段，你可以随意的使用列表拥有的威力与弹性，不需要担心效率。<br/><br/>
若你使用图 5.1 的代码来推出一个时光机器 (time machine)，当你抵达时，人们大概会不同意你的日期。即使是相对近的现在，欧洲的日期曾有过偏移，因为人们会获得更精准的每年有多长的概念。在说英语的国家，最後一次的不连续性出现在 1752 年，日期从 9 月 2 日跳到 9 月 14 日。<br/><br/>
每年有几天取决於它是否是润年。我们说某一年是润年，如果这年可以被四整除，除非这年可以被 100 整除，则此年非润年––而要是它可以被 400 整除，则是润年。所以 1904 年是润年，1900 年不是，而 1600 年是。<br/><br/>
要决定某一个数是否可以被另一个数除，我们使用函数 <tt class="docutils literal">mod</tt> ，它返回相除後的馀数：<br/><br/>

&gt; (mod 23 5)
3
&gt; (mod 25 5)
0
</pre>
如果第一个参数除以第二个参数的馀数为 0，则第一个参数是可以被第二个参数整除的。函数 <tt class="docutils literal">leap?</tt> 使用了这个方法，来决定它的参数是否是一个润年：<br/><br/>

&gt; (mapcar #'leap? '(1904 1900 1600))
(T NIL T)
</pre>
我们用来转换日期至整数的函数是 <tt class="docutils literal"><span class="pre">date-&gt;num</span></tt> 。它返回日期中每个单位的天数总和。要找到从某月份开始的天数和，我们调用 <tt class="docutils literal"><span class="pre">month-num</span></tt> ，它在 <tt class="docutils literal">month</tt> 中查询天数，如果是在润年的二月之後，则加一。<br/><br/>
要找到从某年开始的天数和， <tt class="docutils literal"><span class="pre">date-&gt;num</span></tt> 调用 <tt class="docutils literal"><span class="pre">year-num</span></tt> ，它返回某年一月一日相对於起始点 (2000.01.01)所代表的天数。这个函数的工作方式是从传入的参数 <tt class="docutils literal">y</tt> 年开始，朝着起始年 (2000)往上或往下数。<br/><br/>

(defun num-&gt;date (n)
  (multiple-value-bind (y left) (num-year n)
    (multiple-value-bind (m d) (num-month left y)
      (values d m y))))

(defun num-year (n)
  (if (&lt; n 0)
      (do* ((y (- yzero 1) (- y 1))
            (d (- (year-days y)) (- d (year-days y))))
           ((&lt;= d n) (values y (- n d))))
      (do* ((y yzero (+ y 1))
            (prev 0 d)
            (d (year-days y) (+ d (year-days y))))
           ((&gt; d n) (values (- n prev))))))

(defun num-month (n y)
  (if (leap? y)
      (cond ((= n 59) (values 2 29))
            ((&gt; n 59) (nmon (- n 1)))
            (t        (nmon n)))
      (nmon n)))

(defun nmon (n)
  (let ((m (position n month :test #'&lt;)))
    (values m (+ 1 (- n (svref month (- m 1)))))))

(defun date+ (d m y n)
  (num-&gt;date (+ (date-&gt;num d m y) n)))
</pre>
<strong>图 5.2 日期运算：转换数字至日期</strong><br/><br/>
图 5.2 展示了代码的下半部份。函数 <tt class="docutils literal"><span class="pre">num-&gt;date</span></tt> 将整数转换回日期。它调用了 <tt class="docutils literal"><span class="pre">num-year</span></tt> 函数，以日期的格式返回年以及剩馀的天数。它将剩馀的天数传给 <tt class="docutils literal"><span class="pre">num-month</span></tt> ，分解出月与日。<br/><br/>
和 <tt class="docutils literal"><span class="pre">year-num</span></tt> 一样， <tt class="docutils literal"><span class="pre">num-year</span></tt> 从起始年往上或下数，一次数一年。它持续累积天数，直到它获得一个绝对值大於或等於 <tt class="docutils literal">n</tt>  的数。如果它往下数，那麽它可以返回当前迭代中的数值。不然它会超过年份，然後必须返回前次迭代的数值。这也是为什麽要使用 <tt class="docutils literal">prev</tt> ， <tt class="docutils literal">prev</tt> 在每次迭代时会被存入 <tt class="docutils literal">days</tt> 在前次迭代的数值。<br/><br/>
函数 <tt class="docutils literal"><span class="pre">num-month</span></tt> 以及它的子程序 (subroutine) <tt class="docutils literal">nmon</tt> 的行为像是相反地 <tt class="docutils literal"><span class="pre">month-num</span></tt> 。他们从常数向量 <tt class="docutils literal">month</tt> 的数值到位置，然而 <tt class="docutils literal"><span class="pre">month-num</span></tt> 从位置到数值。<br/><br/>
图 5.2 的前两个函数可以合而为一。与其返回数值给另一个函数， <tt class="docutils literal"><span class="pre">num-year</span></tt> 可以直接调用 <tt class="docutils literal"><span class="pre">num-month</span></tt> 。现在分成两个的代码比较容易交互测试，但是现在它可以工作了，下一步或许是把它合而为一。<br/><br/>
有了 <tt class="docutils literal"><span class="pre">date-&gt;num</span></tt> 与 <tt class="docutils literal"><span class="pre">num-&gt;date</span></tt> ，日期运算是很简单的。我们在 <tt class="docutils literal">date+</tt> 里使用它们，可以从特定的日期做加减。如果我们想透过 <tt class="docutils literal">date+</tt> 来知道 1997 年 12 月 17 日六十天之後的日期:<br/><br/>

&gt; (multiple-value-list (date+ 17 12 1997 60))
(15 2 1988)
</pre>
我们得到 1988 年 2 月 15 日。<br/><br/>


<h1>Chapter 5 总结 (Summary)</h1>
<ol class="arabic simple">
<li>Common Lisp 有三个基本的区块建构子： <tt class="docutils literal">progn</tt> ；允许返回的 <tt class="docutils literal">block</tt> ；以及允许 <tt class="docutils literal">goto</tt> 的 <tt class="docutils literal">tagbody</tt> 。很多内建的操作符都隐含着区块。</li>
<li>进入一个新的词法语境概念上等同於函数调用。</li>
<li>Common Lisp 提供了适合不同情况的条件式。每个都可以使用 <tt class="docutils literal">if</tt> 来定义。</li>
<li>有数个相似迭代操作符的变种。</li>
<li>表达式可以返回多个数值。</li>
<li>计算过程可以被中断以及保护，保护可使其免於中断所造成的後果。</li>
</ol>


<h1>Chapter 5 练习 (Exercises)</h1>
<ol class="arabic simple">
<li>将下列表达式翻译成没有使用 <tt class="docutils literal">let</tt> 与 <tt class="docutils literal">let*</tt> ，并使同样的表达式不被求值 2 次。</li>
</ol>

(a) (let ((x (car y)))
      (cons x x))
(b) (let* ((w (car x))
           (y (+ w z)))
      (cons w y))
</pre>
<ol class="arabic simple" start="2">
<li>使用 <tt class="docutils literal">cond</tt> 重写 29 页的 <tt class="docutils literal">mystery</tt> 函数。（译注: 第二章的练习第 5 题的 (b) 部分)</li>
<li>定义一个返回其参数平方的函数，而当参数是一个正整数且小於等於 5 时，不要计算其平方。</li>
<li>使用 <tt class="docutils literal">case</tt> 与 <tt class="docutils literal">svref</tt> 重写 <tt class="docutils literal"><span class="pre">month-num</span></tt> (图 5.1)。</li>
<li>定义一个迭代与递归版本的函数，接受一个对象 x 与向量 v，并返回一个列表，包含了向量 v 当中，所有直接在 x 之前的对象：</li>
</ol>

&gt; (precedes #\a &quot;abracadabra&quot;)
(#\c #\d #\r)
</pre>
<ol class="arabic simple" start="6">
<li>定义一个迭代与递归版本的函数，接受一个对象与列表，并返回一个新的列表，在原本列表的对象之间加上传入的对象：</li>
</ol>

&gt; (intersperse '- '(a b c d))
(A - B - C - D)
</pre>
<ol class="arabic simple" start="7">
<li>定义一个接受一系列数字的函数，并在若且唯若每一对 (pair)数字的差为一时，返回真，使用</li>
</ol>

(a) 递归
(b) do
(c) mapc 与 return
</pre>
<ol class="arabic simple" start="8">
<li>定义一个单递归函数，返回两个值，分别是向量的最大与最小值。</li>
<li>图 3.12 的程序在找到一个完整的路径时仍持续游遍伫列。在搜索范围大时，这可能会产生问题。</li>
</ol>

(a) 使用 catch 与 throw 来变更程序，使其找到第一个完整路径时，直接返回它。
(b) 重写一个做到同样事情的程序，但不使用 catch 与 throw。
</pre>
