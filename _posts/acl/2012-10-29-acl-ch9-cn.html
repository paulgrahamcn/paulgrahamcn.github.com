---
layout: post
title : "第9章--数字"
category : acl
tags : [acl]
---
{% include JB/setup %}

处理数字是 Common Lisp 的强项之一。Common Lisp 有着丰富的数值类型 (numeric types)，而 Common Lisp 操作数字的特性与其他语言比起来更受人喜爱。<br/><br/>

<h1>9.1 类型 (Types)</h1>
Common Lisp 提供了四种不同类型的数字：整数 (integers)、浮点数 (floating-point numbers)、比值 (ratios) 与复数 (complex number)。本章所描述的函数适用於所有类型的数字。有几个不能用在复数的会特别注明。<br/><br/>
一个整数是写成一串数字： <tt class="docutils literal">2001</tt> 。一个浮点数是可以写成一串包含小数点的数字， <tt class="docutils literal">253.72</tt> ，或是用科学表示法， <tt class="docutils literal">2.5372e2</tt> 。一个比值是写成一个由整数组成的分数： <tt class="docutils literal">2/3</tt> 。而复数 <tt class="docutils literal">a+bi</tt> 是写成 <tt class="docutils literal">#c(a b)</tt> ，其中 <tt class="docutils literal">a</tt> 与 <tt class="docutils literal">b</tt> 是任两个同样类型的实数 (real number)。<br/><br/>
判断式 <tt class="docutils literal">integerp</tt> , <tt class="docutils literal">floatp</tt> 以及 <tt class="docutils literal">complexp</tt> 对於相对应的数字类型返回真。图 9.1 演示了数值类型的层级 (hierarchy of numeric types)。<br/><br/>

<img alt="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-9.1.png" src="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-9.1.png" />

<strong>图 9.1: 数值类型</strong><br/><br/>
以下是某些通用的经验法则，来决定一个计算过程会返回何种数字：<br/><br/>
<ol class="arabic simple">
<li>如果一个数值函数 (numeric function)接受一个或多个浮点数作为参数，则返回值会是一个浮点数 (或是一个由浮点数组成的复数)。所以 <tt class="docutils literal">(+ 1.0 2)</tt> 求值成 <tt class="docutils literal">3.0</tt> ，而 <tt class="docutils literal">(+ #c(0 1.0) 2)</tt> 求值成 <tt class="docutils literal">#c(2.0 1.0)</tt> 。</li>
<li>可约分的比值会被转换成整数。所以 <tt class="docutils literal">(/ 10 2)</tt> 会返回 <tt class="docutils literal">5</tt> 。</li>
<li>若计算过程中复数的虚部会变成 <tt class="docutils literal">0</tt> ，则复数会被转成实数 。所以 <tt class="docutils literal">(+ #c(1 <span class="pre">-1)</span> #c(2 1))</tt> 求值成 <tt class="docutils literal">3</tt> 。</li>
</ol>
第二、第三个规则可以在参数被读取时直接应用，所以：<br/><br/>

&gt; (list (ratiop 2/2) (complexp #c(1 0)))
(NIL NIL)
</pre>


<h1>9.2 转换及取出 (Conversion and Extraction)</h1>
Lisp 提供函数来做四种不同类型的数字的转换 (converting)及取出位数 (extracting component)。函数 <tt class="docutils literal">float</tt> 将任何实数转换成一个浮点数:<br/><br/>

&gt; (mapcar #'float '(1 2/3 .5))
(1.0 0.6666667 0.5)
</pre>
将数字转成整数未必需要转换，因为它可能牵涉到某些资讯的丧失。函数 <tt class="docutils literal">truncate</tt> 返回任何实数的整数部分:<br/><br/>

&gt; (truncate 1.3)
1
0.29999995
</pre>
第二个返回值是传入的参数减去第一个返回值。(会有 0.00000005 的差是因为浮点数的计算本来就不精确。)<br/><br/>
函数 <tt class="docutils literal">floor</tt> 与 <tt class="docutils literal">ceiling</tt> 以及 <tt class="docutils literal">round</tt> 也从它们的参数中导出整数。使用 <tt class="docutils literal">floor</tt> 返回小於等於其参数的最大整数，而 <tt class="docutils literal">ceiling</tt> 返回大於或等於其参数的最小整数，我们可以将 <tt class="docutils literal">mirror?</tt> (46 页，译注: 3.11 节)改成可以找出所有回文 (palindromes)的版本:<br/><br/>

(defun palindrome? (x)
  (let ((mid (/ (length x) 2)))
    (equal (subseq x 0 (floor mid))
           (reverse (subseq x (ceiling mid))))))
</pre>
和 <tt class="docutils literal">truncate</tt> 一样， <tt class="docutils literal">floor</tt> 与 <tt class="docutils literal">ceiling</tt> 也返返回入参数与第一个返回值的差作为第二个值。<br/><br/>

&gt; (floor 1.5)
1
0.5
</pre>
实际上，我们可以把 <tt class="docutils literal">truncate</tt> 想成是这样定义的:<br/><br/>

(defun our-truncate (n)
    (if (&gt; n 0)
        (floor n)
        (ceiling n)))
</pre>
函数 <tt class="docutils literal">round</tt> 返回最接近其参数的整数。当参数与两个整数的距离相等时， Common Lisp 和很多程序语言一样，不会往上取 (round up)整数。而是取最近的偶数:<br/><br/>

&gt; (mapcar #'round '(-2.5 -1.5 1.5 2.5))
(-2 -2 2 2)
</pre>
在某些数值应用中这是好事，因为舍入误差 (rounding error)倾向於互相抵消。然而如果用户期望你的程序将某些值取整数时，你必须自己提供这个功能。 <a class="footnote-reference" href="#id5" id="id1">[1]</a> 与其他的函数一样， <tt class="docutils literal">round</tt> 返返回入参数与第一个返回值的差作为第二个值。<br/><br/>
函数 <tt class="docutils literal">mod</tt> 仅返回 <tt class="docutils literal">floor</tt> 会返回的第二个值；而 <tt class="docutils literal">rem</tt> 返回 <tt class="docutils literal">truncate</tt> 会返回的第二个值。我们在 94 页 (译注: 5.7 节)使用了 <tt class="docutils literal">mod</tt> 来决定一个数是否可被另一个整除，以及 127 页(译注: 7.4 节)用来找出环状缓冲区 (ring buffer)中，元素实际的位置。<br/><br/>
关於实数，函数 <tt class="docutils literal">signum</tt> 返回 <tt class="docutils literal">1</tt> , <tt class="docutils literal">0</tt> 或 <tt class="docutils literal"><span class="pre">-1</span></tt> ，取决於它的参数是正、零或负数。函数 <tt class="docutils literal">abs</tt> 返回其参数的绝对值。因此 <tt class="docutils literal">(* (abs x) (signum x))</tt> 等於 <tt class="docutils literal">x</tt> 。<br/><br/>

&gt; (mapcar #'signum '(-2 -0.0 0.0 0 .5 3))
(-1 -0.0 0.0 0 1.0 1)
</pre>
在某些应用里， <tt class="docutils literal"><span class="pre">-0.0</span></tt> 可能自成一格 (in its own right)，如上所示。其实功能上它几乎没有差异，因为数值 <tt class="docutils literal"><span class="pre">-0.0</span></tt> 与 <tt class="docutils literal">0.0</tt> 有一样的行为。<br/><br/>
比值与复数概念上是两部分结构。(译注: 像 <strong>Cons</strong> 这样的两部分结构) 函数 <tt class="docutils literal">numerator</tt> 与 <tt class="docutils literal">denominator</tt> 返回一个比值或整数所对应的部份。 (如果数字是整数，前者返回该数字，而後者返回 <tt class="docutils literal">1</tt> 。)函数 <tt class="docutils literal">realpart</tt> 与 <tt class="docutils literal">imgpart</tt> 返回任何数字的实数与虚数部分。 (如果数字不是复数，前者返回该数字，後者返回 <tt class="docutils literal">0</tt> 。)<br/><br/>
函数 <tt class="docutils literal">random</tt> 接受一个整数或浮点数。一个这样形式的表达式 <tt class="docutils literal">(random n)</tt> 返回一个大於或小於等於 <tt class="docutils literal">n</tt> 的数字，并有着与 <tt class="docutils literal">n</tt> 相同的类型。<br/><br/>


<h1>9.3 比较 (Comparison)</h1>
判断式 <tt class="docutils literal">=</tt> 当其参数数值上相等时 –– 即两者的差为零时，返回真。<br/><br/>

&gt; (= 1 1.0)
T
&gt; (eql 1 1.0)
NIL
</pre>
<tt class="docutils literal">=</tt> 比起 <tt class="docutils literal">eql</tt> 来得宽松，但它的参数需要是同样类型。<br/><br/>
用来比较数字的判断式为 <tt class="docutils literal">&lt;</tt> (小於), <tt class="docutils literal">&lt;=</tt> (小於等於), <tt class="docutils literal">=</tt> (等於), <tt class="docutils literal">&gt;=</tt> (大於等於), <tt class="docutils literal">&gt;</tt> (大於) 以及 <tt class="docutils literal">/=</tt> (不同)。以上所有皆接受一个或多个参数。只有一个参数时，它们全返回真。<br/><br/>

(&lt;= w x y z)
</pre>
等同於一个二元操作符的结合 (conjunction)，应用至每一对参数上:<br/><br/>

(and (&lt;= w x) (&lt;= x y) (&lt;= y z))
</pre>
由於 <tt class="docutils literal">/=</tt> 若它的两个参数不等於时返回真，表达式<br/><br/>

(/= w x y z)
</pre>
等同於<br/><br/>

(and (/= w x) (/= w y) (/= w z)
     (/= x y) (/= y z) (/= y z))
</pre>
特殊的判断式 <tt class="docutils literal">zerop</tt> , <tt class="docutils literal">plusp</tt> 与 <tt class="docutils literal">minusp</tt> 接受一个参数，分别於参数 <tt class="docutils literal">=</tt> , <tt class="docutils literal">&gt;</tt> , <tt class="docutils literal">&lt;</tt> 零时，返回真。虽然 <tt class="docutils literal"><span class="pre">-0.0</span></tt> (如果实现有使用它) 前面有个负号，但它 <tt class="docutils literal">=</tt> 零，<br/><br/>

&gt; (list (minusp -0.0) (zerop -0.0))
(NIL T)
</pre>
因此使用 <tt class="docutils literal">zerop</tt> 而不是 <tt class="docutils literal">minusp</tt> 。<br/><br/>
判断式 <tt class="docutils literal">oddp</tt> 与 <tt class="docutils literal">evenp</tt> 只能用在整数。前者只对奇数返回真，後者只对偶数返回真。<br/><br/>
本节定义的判断式中，只有 <tt class="docutils literal">=</tt> , <tt class="docutils literal">/=</tt> 与 <tt class="docutils literal">zerop</tt> 可以用在复数。<br/><br/>
函数 <tt class="docutils literal">max</tt> 与 <tt class="docutils literal">min</tt> 分别返回其参数的最大值与最小值。两者至少需要给一个参数:<br/><br/>

&gt; (list (max 1 2 3 4 5) (min 1 2 3 4 5))
(5 1)
</pre>
如果参数有包含浮点数的话，结果的类型取决於各家实现。<br/><br/>


<h1>9.4 算术 (Arithematic)</h1>
用来做加减的函数是 <tt class="docutils literal">+</tt> 与 <tt class="docutils literal">-</tt> 。两者皆可接受任何数量的参数，包括没有参数，在没有参数的情况下返回 <tt class="docutils literal">0</tt> 。(译注: <tt class="docutils literal">-</tt> 在没有参数的情况下会报错，至少要一个参数) 一个这样形式的表达式 <tt class="docutils literal">(- n)</tt> 返回 <tt class="docutils literal"><span class="pre">-n</span></tt> 。一个这样形式的表达式<br/><br/>

(- x y z)
</pre>
等同於<br/><br/>

(- (- x y) z)
</pre>
有两个函数 <tt class="docutils literal">1+</tt> 与 <tt class="docutils literal">1-</tt> ，分别将参数加上 <tt class="docutils literal">1</tt> 与减去 <tt class="docutils literal">1</tt> 并返回。 <tt class="docutils literal">1-</tt> 有一点误导，因为 <tt class="docutils literal">(1- x)</tt> 返回 <tt class="docutils literal"><span class="pre">x-1</span></tt> 而不是 <tt class="docutils literal"><span class="pre">1-x</span></tt> 。<br/><br/>
宏 <tt class="docutils literal">incf</tt> 及     <tt class="docutils literal">decf</tt> 分别增加与减少参数。一个这样形式的表达式 <tt class="docutils literal">(incf x n)</tt> 类似於 <tt class="docutils literal">(setf x (+ x n))</tt> 的效果，而 <tt class="docutils literal">(decf x n)</tt> 类似於 <tt class="docutils literal">(setf x (- x n))</tt> 的效果。这两个情况里，第二个参数是选择性的并缺省为 <tt class="docutils literal">1</tt> 。<br/><br/>
用来做乘法的函数是 <tt class="docutils literal">*</tt> 。接受任何数量的参数。没有给参数时返回 <tt class="docutils literal">1</tt> 。否则返回参数的乘积。<br/><br/>
除法函数 <tt class="docutils literal">/</tt> 至少预期一个参数。一个这样形式的调用 <tt class="docutils literal">(/ n)</tt> 等同於 <tt class="docutils literal">(/ 1 n)</tt> ，<br/><br/>

&gt; (/ 3)
1/3
</pre>
而一个这样形式的调用<br/><br/>

(/ x y z)
</pre>
等同於<br/><br/>

(/ (/ x y) z)
</pre>
注意 <tt class="docutils literal">-</tt> 与 <tt class="docutils literal">/</tt> 两者在这方面的相似性。<br/><br/>
当给定两个整数时， <tt class="docutils literal">/</tt> 若第一个不是第二个的倍数时，会返回一个比值:<br/><br/>

&gt; (/ 365 12)
365/12
</pre>
举例来说，如果你试着找出平均每一个月有多长，你可能会有顶层在逗你玩的想法。在这个情况下，你需要的是对比值调用 <tt class="docutils literal">float</tt> ，而不是对两个整数做 <tt class="docutils literal">/</tt> 。<br/><br/>

&gt; (float 365/12)
30.416666
</pre>


<h1>9.5 指数 (Exponentiation)</h1>
要找到 <span class="math">
\(x^n\)</span>
 我们调用 <tt class="docutils literal">(expt x n)</tt> ，<br/><br/>

&gt; (expt 2 5)
32
</pre>
而要找到 <span class="math">
\(log_nx\)</span>
 我们调用 <tt class="docutils literal">(log x n)</tt> :<br/><br/>

&gt; (log 32 2)
5.0
</pre>
通常返回一个浮点数。<br/><br/>
要找到 <span class="math">
\(e^x\)</span>
 有一个特别的函数 <tt class="docutils literal">exp</tt> ，<br/><br/>

&gt; (exp 2)
7.389056
</pre>
而要找到一个自然对数，你可以使用 <tt class="docutils literal">log</tt> 就好，因为第二个参数缺省为 <tt class="docutils literal">e</tt> :<br/><br/>

&gt; (log 7.389056)
2.0
</pre>
要找到立方根，你可以调用 <tt class="docutils literal">expt</tt> 用一个比值作为第二个参数，<br/><br/>

&gt; (expt 27 1/3)
3.0
</pre>
但要找到平方根，函数 <tt class="docutils literal">sqrt</tt> 会比较快:<br/><br/>

&gt; (sqrt 4)
2.0
</pre>


<h1>9.6 三角函数 (Trigometric Functions)</h1>
常量 <tt class="docutils literal">pi</tt> 是 <tt class="docutils literal">π</tt> 的浮点表示法。它的精度 (precision)取决於各家实现。函数 <tt class="docutils literal">sin</tt> , <tt class="docutils literal">cos</tt> 及 <tt class="docutils literal">tan</tt> 分别可以找到正弦、馀弦及正交函数，其中角度以径度 (radian)表示:<br/><br/>

&gt; (let ((x (/ pi 4)))
    (list (sin x) (cos x) (tan x)))
(0.7071067811865475d0 0.7071067811865476d0 1.0d0)
;;; 译注: CCL 1.8  SBCL 1.0.55 下的结果是
;;; (0.7071067811865475D0 0.7071067811865476D0 0.9999999999999999D0)
</pre>
这些函数全部接受负数及复数参数。<br/><br/>
函数 <tt class="docutils literal">asin</tt> , <tt class="docutils literal">acos</tt> 及 <tt class="docutils literal">atan</tt> 实现了正弦、馀弦及正交的反函数 (inverse)。参数介於 <tt class="docutils literal"><span class="pre">-1</span></tt> 与 <tt class="docutils literal">1</tt> 之间（包含）时， <tt class="docutils literal">asin</tt> 与 <tt class="docutils literal">acos</tt> 返回实数。<br/><br/>
双曲 (hyperbolic)正弦、馀弦及正交分别由 <tt class="docutils literal">sinh</tt> , <tt class="docutils literal">cosh</tt> 及 <tt class="docutils literal">tanh</tt> 实现。它们的反函数同样为 <tt class="docutils literal">asinh</tt> , <tt class="docutils literal">acosh</tt> 以及 <tt class="docutils literal">atanh</tt> 。<br/><br/>


<h1>9.6 三角函数 (Trigometric Functions)</h1>
常量 <tt class="docutils literal">pi</tt> 是 <tt class="docutils literal">π</tt> 的浮点表示法。它的精度 (precision)取决於各家实现。函数 <tt class="docutils literal">sin</tt> , <tt class="docutils literal">cos</tt> 及 <tt class="docutils literal">tan</tt> 分别可以找到正弦、馀弦及正交函数，其中角度以径度 (radian)表示:<br/><br/>

&gt; (let ((x (/ pi 4)))
    (list (sin x) (cos x) (tan x)))
(0.7071067811865475d0 0.7071067811865476d0 1.0d0)
;;; 译注: CCL 1.8  SBCL 1.0.55 下的结果是
;;; (0.7071067811865475D0 0.7071067811865476D0 0.9999999999999999D0)
</pre>
这些函数全部接受负数及复数参数。<br/><br/>
函数 <tt class="docutils literal">asin</tt> , <tt class="docutils literal">acos</tt> 及 <tt class="docutils literal">atan</tt> 实现了正弦、馀弦及正交的反函数 (inverse)。参数介於 <tt class="docutils literal"><span class="pre">-1</span></tt> 与 <tt class="docutils literal">1</tt> 之间（包含）时， <tt class="docutils literal">asin</tt> 与 <tt class="docutils literal">acos</tt> 返回实数。<br/><br/>
双曲的 (hyperbolic)正弦、馀弦及正交分别由 <tt class="docutils literal">sinh</tt> , <tt class="docutils literal">cosh</tt> 及 <tt class="docutils literal">tanh</tt> 实现。它们的反函数同样为 <tt class="docutils literal">asinh</tt> , <tt class="docutils literal">acosh</tt> 以及 <tt class="docutils literal">atanh</tt> 。<br/><br/>


<h1>9.7 表示法 (Representations)</h1>
Common Lisp 对於整数的大小没有限制。可以塞进一个字 (word)内存的小整数称为定数 (fixnums)。当一个计算过程整数无法塞入一个字 (word)时，Lisp 切换至使用多个内存字的表示法（一个大数 「bignum」)。所以一个整数的大小限制取决於实体内存，而不是语言。<br/><br/>
常量 <tt class="docutils literal"><span class="pre">most-positive-fixnum</span></tt> 与 <tt class="docutils literal"><span class="pre">most-negative-fixnum</span></tt> 表示了一个实现不使用大数 (bignum)可表示的最大数字幅度 (magnitude)。在很多实现里，它们为：<br/><br/>

&gt; (values most-positive-fixnum most-negative-fixnum)
536870911
-536870912
;;; 译注: CCL 1.8 的结果为
1152921504606846975
-1152921504606846976
;;; SBCL 1.0.55 的结果为
4611686018427387903
-4611686018427387904
</pre>
判断式 <tt class="docutils literal">typep</tt> 接受一个参数及一个类型名称，并返回指定类型的参数。所以，<br/><br/>

&gt; (typep 1 'fixnum)
T
&gt; (type (1+ most-positive-fixnum) 'bignum)
T
</pre>
浮点数字的数值限制是取决於各家实现的。 Common Lisp 提供了最多四种类型的浮点数：短浮点 <tt class="docutils literal"><span class="pre">short-float</span></tt> 、 单浮点 <tt class="docutils literal"><span class="pre">single-float</span></tt> 、双浮点 <tt class="docutils literal"><span class="pre">double-float</span></tt> 以及长浮点 <tt class="docutils literal"><span class="pre">long-float</span></tt> 。Common Lisp 的实现不需要用不同的格式来表示这四种类型（很少实现这麽做）。<br/><br/>
一般来说，短浮点应可塞入一个字 (word)，单浮点与双浮点提供普遍的单与双精度浮点数的概念，而长浮点，如果想要的话可以是很大的数。但一个实现可以使这四个类型没有区别，也是完全没有问题的。<br/><br/>
你可以指定你想要何种格式的浮点数，当一个数字是用科学表示法时，可以通过将 <tt class="docutils literal">e</tt> 替换为 <tt class="docutils literal">s</tt> <tt class="docutils literal">f</tt> <tt class="docutils literal">d</tt> <tt class="docutils literal">l</tt> 来得到不同的浮点数。(你也可以使用大写，这对长浮点来说是个好主意，因为 <tt class="docutils literal">l</tt> 看起来太像 <tt class="docutils literal">1</tt> 了。)所以要表示最大的 <tt class="docutils literal">1.0</tt> 你可以写 <tt class="docutils literal">1L0</tt> 。<br/><br/>
(译注: <tt class="docutils literal">s</tt> 为短浮点、 <tt class="docutils literal">f</tt> 为单浮点、 <tt class="docutils literal">d</tt> 为双浮点、 <tt class="docutils literal">l</tt> 为长浮点。)<br/><br/>
在给定的实现里，用十六个全局常量标明了每个格式的限制。它们的名字是这种形式: <tt class="docutils literal"><span class="pre">m-s-f</span></tt> ，其中 <tt class="docutils literal">m</tt> 是 <tt class="docutils literal">most</tt> 或 <tt class="docutils literal">least</tt> ， <tt class="docutils literal">s</tt> 是 <tt class="docutils literal">positive</tt> 或 <tt class="docutils literal">negative</tt> ，而 <tt class="docutils literal">f</tt> 是四种浮点数之一。 <a class="reference external" href="http://ansi-common-lisp.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-150">λ</a><br/><br/>
浮点数乾涸与溢出被 Common Lisp 视为错误 :<br/><br/>
(译注: 这里调皮了一下，使用了乾涸。我们说一个 stack 满了要 push 时叫做溢出 (overflow)，stack 为空又要 pop 时叫做下溢「underflow」，但是下溢听起来以为是裤子湿了…)<br/><br/>

&gt; (* most-positive-long-float 10)
Error: floating-point-overflow
</pre>


<h1>9.8 范例：追踪光线 (Example: Ray-Tracing)</h1>
作为一个数值应用的范例，本节示范了如何撰写一个光线追踪器 (ray-tracer)。光线追踪是一个高级的 (deluxe)渲染算法: 它产生出逼真的图像，但需要花点时间。<br/><br/>
要产生一个 3D 的图像，我们至少需要定义四件事: 一个观测点 (eye)、一个或多个光源、一个由一个或多个平面所组成的模拟世界 (simulated world)，以及一个作为通往这个世界的窗户的平面 (图像平面「image plane」)。我们产生出的是模拟世界投影在图像平面区域的图像。<br/><br/>
让光线追踪如此不寻常的是，我们如何找到这个投影: 我们一个一个像素地沿着图像平面走，追踪回到模拟世界里的光线。这个方法带来三个主要的优势: 它让我们容易得到现实世界的光学效应 (optical effect)，如透明度 (transparency)、反射光 (reflected light)以及产生阴影 (cast shadows)；它让我们可以直接用任何我们想要的几何的物体，来定义出模拟的世界，而不需要用多变形 (polygons)来建构它们；以及它很简单实现。<br/><br/>

(defun sq (x) (* x x))

(defun mag (x y z)
  (sqrt (+ (sq x) (sq y) (sq z))))

(defun unit-vector (x y z)
  (let ((d (mag x y z)))
    (values (/ x d) (/ y d) (/ z d))))

(defstruct (point (:conc-name nil))
  x y z)

(defun distance (p1 p2)
  (mag (- (x p1) (x p2))
       (- (y p1) (y p2))
       (- (z p1) (z p2))))

(defun minroot (a b c)
  (if (zerop a)
      (/ (- c) b)
      (let ((disc (- (sq b) (* 4 a c))))
        (unless (minusp disc)
          (let ((discrt (sqrt disc)))
            (min (/ (+ (- b) discrt) (* 2 a))
                 (/ (- (- b) discrt) (* 2 a))))))))
</pre>
<strong>图 9.2 实用数学函数</strong><br/><br/>
图 9.2 包含了我们在光线追踪器里会需要用到的一些实用数学函数。第一个 <tt class="docutils literal">sq</tt> ，返回其参数的平方。下一个 <tt class="docutils literal">mag</tt> ，返回一个给定 <tt class="docutils literal">x</tt> <tt class="docutils literal">y</tt> <tt class="docutils literal">z</tt> 所组成向量的大小 (magnitude)。这个函数被接下来两个函数用到。我们在 <tt class="docutils literal"><span class="pre">unit-vector</span></tt> 用到了，此函数返回三个数值，来表示与单位向量有着同样方向的向量，其中向量是由 <tt class="docutils literal">x</tt> <tt class="docutils literal">y</tt> <tt class="docutils literal">z</tt> 所组成的:<br/><br/>

&gt; (multiple-value-call #'mag (unit-vector 23 12 47))
1.0
</pre>
我们在 <tt class="docutils literal">distance</tt> 也用到了 <tt class="docutils literal">mag</tt> ，它返回三维空间中，两点的距离。（定义 <tt class="docutils literal">point</tt> 结构来有一个 <tt class="docutils literal">nil</tt> 的 <tt class="docutils literal"><span class="pre">conc-name</span></tt> 意味着栏位存取的函数会有跟栏位一样的名字: 举例来说， <tt class="docutils literal">x</tt> 而不是 <tt class="docutils literal"><span class="pre">point-x</span></tt> 。)<br/><br/>
最後 <tt class="docutils literal">minroot</tt> 接受三个实数， <tt class="docutils literal">a</tt> , <tt class="docutils literal">b</tt> 与 <tt class="docutils literal">c</tt> ，并返回满足等式 <span class="math">
\(ax^2+bx+c=0\)</span>
 的最小实数 <tt class="docutils literal">x</tt> 。当 <tt class="docutils literal">a</tt> 不为 0 时，这个等式的根由下面这个熟悉的式子给出:<br/><br/>

\begin{equation*}
x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}
\end{equation*}

图 9.3 包含了定义一个最小光线追踪器的代码。 它产生通过单一光源照射的黑白图像，与观测点 (eye)处於同个位置。 (结果看起来像是闪光摄影术 (flash photography)拍出来的)<br/><br/>
<tt class="docutils literal">surface</tt> 结构会用来表示模拟世界中的物体。更精确的说，它会被 <tt class="docutils literal">included</tt> 至定义具体类型物体的结构里，像是球体 (spheres)。 <tt class="docutils literal">surface</tt> 结构本身只包含一个栏位: 一个 <tt class="docutils literal">color</tt> 范围从 0 (黑色) 至 1 (白色)。<br/><br/>

(defstruct surface  color)

(defparameter *world* nil)
(defconstant eye (make-point :x 0 :y 0 :z 200))

(defun tracer (pathname &amp;optional (res 1))
  (with-open-file (p pathname :direction :output)
    (format p &quot;P2 ~A ~A 255&quot; (* res 100) (* res 100))
    (let ((inc (/ res)))
      (do ((y -50 (+ y inc)))
          ((&lt; (- 50 y) inc))
        (do ((x -50 (+ x inc)))
            ((&lt; (- 50 x) inc))
          (print (color-at x y) p))))))

(defun color-at (x y)
  (multiple-value-bind (xr yr zr)
                       (unit-vector (- x (x eye))
                                    (- y (y eye))
                                    (- 0 (z eye)))
    (round (* (sendray eye xr yr zr) 255))))

(defun sendray (pt xr yr zr)
  (multiple-value-bind (s int) (first-hit pt xr yr zr)
    (if s
        (* (lambert s int xr yr zr) (surface-color s))
        0)))

(defun first-hit (pt xr yr zr)
  (let (surface hit dist)
    (dolist (s *world*)
      (let ((h (intersect s pt xr yr zr)))
        (when h
          (let ((d (distance h pt)))
            (when (or (null dist) (&lt; d dist))
              (setf surface s hit h dist d))))))
    (values surface hit)))

(defun lambert (s int xr yr zr)
  (multiple-value-bind (xn yn zn) (normal s int)
    (max 0 (+ (* xr xn) (* yr yn) (* zr zn)))))
</pre>
<strong>图 9.3 光线追踪。</strong><br/><br/>
图像平面会是由 x 轴与 y 轴所定义的平面。观测者 (eye) 会在 z 轴，距离原点 200 个单位。所以要在图像平面可以被看到，插入至 <tt class="docutils literal">*worlds*</tt> 的表面 (一开始为 <tt class="docutils literal">nil</tt>)会有着负的 z 座标。图 9.4 说明了一个光线穿过图像平面上的一点，并击中一个球体。<br/><br/>

<img alt="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-9.4.png" src="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-9.4.png" />

<strong>图 9.4: 追踪光线。</strong><br/><br/>
函数 <tt class="docutils literal">tracer</tt> 接受一个路径名称，并写入一张图片至对应的文件。图片文件会用一种简单的 ASCII 称作 PGM 的格式写入。默认情况下，图像会是 100x100 。我们 PGM 文件的标头 (headers) 会由标签 <tt class="docutils literal">P2</tt> 组成，伴随着指定图片宽度 (breadth)与高度 (height)的整数，初始为 100，单位为 pixel，以及可能的最大值 (255)。文件剩馀的部份会由 10000 个介於 0 (黑)与 1 (白)整数组成，代表着 100 条 100 像素的水平线。<br/><br/>
图片的解析度可以通过给入明确的 <tt class="docutils literal">res</tt> 来调整。举例来说，如果 <tt class="docutils literal">res</tt> 是 <tt class="docutils literal">2</tt> ，则同样的图像会被渲染成 200x200 。<br/><br/>
图片是一个在图像平面 100x100 的正方形。每一个像素代表着穿过图像平面抵达观测点的光的数量。要找到每个像素光的数量， <tt class="docutils literal">tracer</tt> 调用 <tt class="docutils literal"><span class="pre">color-at</span></tt> 。这个函数找到从观测点至该点的向量，并调用 <tt class="docutils literal">sendray</tt> 来追踪这个向量回到模拟世界的轨迹； <tt class="docutils literal">sandray</tt> 会返回一个数值介於 0 与 1 之间的亮度 (intensity)，之後会缩放成一个 0 至 255 的整数来显示。<br/><br/>
要决定一个光线的亮度， <tt class="docutils literal">sendray</tt> 需要找到光是从哪个物体所反射的。要办到这件事，我们调用 <tt class="docutils literal"><span class="pre">first-hit</span></tt> ，此函数研究在 <tt class="docutils literal">*world*</tt> 里的所有平面，并返回光线最先抵达的平面（如果有的话）。如果光没有击中任何东西， <tt class="docutils literal">sendray</tt> 仅返回背景颜色，按惯例是 <tt class="docutils literal">0</tt> (黑色)。如果光线有击中某物的话，我们需要找出在光击中时，有多少数量的光照在该平面。<br/><br/>
<a class="reference external" href="http://zh.wikipedia.org/zh-tw/%E6%AF%94%E5%B0%94%EF%BC%8D%E6%9C%97%E4%BC%AF%E5%AE%9A%E5%BE%8B">朗伯定律</a> 告诉我们，由平面上一点所反射的光的强度，正比於该点的单位法向量 (unit normal vector) <em>N</em> (这里是与平面垂直且长度为一的向量)与该点至光源的单位向量 <em>L</em> 的点积 (dot-product):<br/><br/>

\begin{equation*}
i = N·L
\end{equation*}

如果光刚好照到这点， <em>N</em> 与 <em>L</em> 会重合 (coincident)，则点积会是最大值， <tt class="docutils literal">1</tt> 。如果将在这时候将平面朝光转 90 度，则 <em>N</em> 与 <em>L</em> 会垂直，则两者点积会是 <tt class="docutils literal">0</tt> 。如果光在平面後面，则点积会是负数。<br/><br/>
在我们的程序里，我们假设光源在观测点 (eye)，所以 <tt class="docutils literal">lambert</tt> 使用了这个规则来找到平面上某点的亮度 (illumination)，返回我们追踪的光的单位向量与法向量的点积。<br/><br/>
在 <tt class="docutils literal">sendray</tt> 这个值会乘上平面的颜色 (即便是有好的照明，一个暗的平面还是暗的)来决定该点之後总体亮度。<br/><br/>
为了简单起见，我们在模拟世界里会只有一种物体，球体。图 9.5 包含了与球体有关的代码。球体结构包含了 <tt class="docutils literal">surface</tt> ，所以一个球体会有一种颜色以及 <tt class="docutils literal">center</tt> 和 <tt class="docutils literal">radius</tt> 。调用 <tt class="docutils literal">defsphere</tt> 添加一个新球体至世界里。<br/><br/>

(defstruct (sphere (:include surface))
  radius center)

(defun defsphere (x y z r c)
  (let ((s (make-sphere
             :radius r
             :center (make-point :x x :y y :z z)
             :color  c)))
    (push s *world*)
    s))

(defun intersect (s pt xr yr zr)
  (funcall (typecase s (sphere #'sphere-intersect))
           s pt xr yr zr))

(defun sphere-intersect (s pt xr yr zr)
  (let* ((c (sphere-center s))
         (n (minroot (+ (sq xr) (sq yr) (sq zr))
                     (* 2 (+ (* (- (x pt) (x c)) xr)
                             (* (- (y pt) (y c)) yr)
                             (* (- (z pt) (z c)) zr)))
                     (+ (sq (- (x pt) (x c)))
                        (sq (- (y pt) (y c)))
                        (sq (- (z pt) (z c)))
                        (- (sq (sphere-radius s)))))))
    (if n
        (make-point :x  (+ (x pt) (* n xr))
                    :y  (+ (y pt) (* n yr))
                    :z  (+ (z pt) (* n zr))))))

(defun normal (s pt)
  (funcall (typecase s (sphere #'sphere-normal))
           s pt))

(defun sphere-normal (s pt)
  (let ((c (sphere-center s)))
    (unit-vector (- (x c) (x pt))
                 (- (y c) (y pt))
                 (- (z c) (z pt)))))
</pre>
<strong>图 9.5 球体。</strong><br/><br/>
函数 <tt class="docutils literal">intersect</tt> 判断与何种平面有关，并调用对应的函数。在此时只有一种， <tt class="docutils literal"><span class="pre">sphere-intersect</span></tt> ，但 <tt class="docutils literal">intersect</tt> 是写成可以容易扩展处理别种物体。<br/><br/>
我们要怎麽找到一束光与一个球体的交点 (intersection)呢？光线是表示成点 <span class="math">
\(p =〈x_0,y_0,x_0〉\)</span>
 以及单位向量 <span class="math">
\(v =〈x_r,y_r,x_r〉\)</span>
 。每个在光上的点可以表示为 <span class="math">
\(p+nv\)</span>
 ，对於某个 <em>n</em> –– 即 <span class="math">
\(〈x_0+nx_r,y_0+ny_r,z_0+nz_r〉\)</span>
 。光击中球体的点的距离至中心 <span class="math">
\(〈x_c,y_c,z_c〉\)</span>
 会等於球体的半径 <em>r</em> 。所以在下列这个交点的方程序会成立:<br/><br/>

\begin{equation*}
r = \sqrt{ (x_0 + nx_r + x_c)^2 + (y_0 + ny_r + y_c)^2 + (z_0 + nz_r + z_c)^2 }
\end{equation*}

这会给出<br/><br/>

\begin{equation*}
an^2 + bn + c = 0
\end{equation*}

其中<br/><br/>

\begin{align*}
a = x_r^2 + y_r^2 + z_r^2\\b = 2((x_0-x_c)x_r + (y_0-y_c)y_r + (z_0-z_c)z_r)\\c = (x_0-x_c)^2 + (y_0-y_c)^2 + (z_0-z_c)^2 - r^2
\end{align*}

要找到交点我们只需要找到这个二次方程序的根。它可能是零、一个或两个实数根。没有根代表光没有击中球体；一个根代表光与球体交於一点 (擦过 「grazing hit」)；两个根代表光与球体交於两点 (一点交於进入时、一点交於离开时)。在最後一个情况里，我们想要两个根之中较小的那个； <em>n</em> 与光离开观测点的距离成正比，所以先击中的会是较小的 <em>n</em> 。所以我们调用 <tt class="docutils literal">minroot</tt> 。如果有一个根， <tt class="docutils literal"><span class="pre">sphere-intersect</span></tt> 返回代表该点的 <span class="math">
\(〈x_0+nx_r,y_0+ny_r,z_0+nz_r〉\)</span>
 。<br/><br/>
图 9.5 的另外两个函数， <tt class="docutils literal">normal</tt> 与 <tt class="docutils literal"><span class="pre">sphere-normal</span></tt> 类比於 <tt class="docutils literal">intersect</tt> 与 <tt class="docutils literal"><span class="pre">sphere-intersect</span></tt> 。要找到垂直於球体很简单 –– 不过是从该点至球体中心的向量而已。<br/><br/>
图 9.6 示范了我们如何产生图片； <tt class="docutils literal"><span class="pre">ray-test</span></tt> 定义了 38 个球体（不全都看的见）然後产生一张图片，叫做 &quot;sphere.pgm&quot; 。<br/><br/>
(译注：PGM 可移植灰度图格式，更多信息参见 <a class="reference external" href="http://en.wikipedia.org/wiki/Portable_graymap">wiki</a> )<br/><br/>

(defun ray-test (&amp;optional (res 1))
  (setf *world* nil)
  (defsphere 0 -300 -1200 200 .8)
  (defsphere -80 -150 -1200 200 .7)
  (defsphere 70 -100 -1200 200 .9)
  (do ((x -2 (1+ x)))
      ((&gt; x 2))
    (do ((z 2 (1+ z)))
        ((&gt; z 7))
      (defsphere (* x 200) 300 (* z -400) 40 .75)))
  (tracer (make-pathname :name &quot;spheres.pgm&quot;) res))
</pre>
<strong>图 9.6 使用光线追踪器</strong><br/><br/>
图 9.7 是产生出来的图片，其中 <tt class="docutils literal">res</tt> 参数为 10。<br/><br/>

<img alt="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-9.7.png" src="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-9.7.png" />

<strong>图 9.7: 追踪光线的图</strong><br/><br/>
一个实际的光线追踪器可以产生更复杂的图片，因为它会考虑更多，我们只考虑了单一光源至平面某一点。可能会有多个光源，每一个有不同的强度。它们通常不会在观测点，在这个情况程序需要检查至光源的向量是否与其他平面相交，这会在第一个相交的平面上产生阴影。将光源放置於观测点让我们不需要考虑这麽复杂的情况，因为我们看不见在阴影中的任何点。<br/><br/>
一个实际的光线追踪器不仅追踪光第一个击中的平面，也会加入其它平面的反射光。一个实际的光线追踪器会是有颜色的，并可以模型化出透明或是闪耀的平面。但基本的算法会与图 9.3 所演示的差不多，而许多改进只需要递回的使用同样的成分。<br/><br/>
一个实际的光线追踪器可以是高度优化的。这里给出的程序为了精简写成，甚至没有如 Lisp 程序员会最佳化的那样，就仅是一个光线追踪器而已。仅加入类型与行内宣告 (13.3 节)就可以让它变得两倍以上快。<br/><br/>


<h1>Chapter 9 总结 (Summary)</h1>
<ol class="arabic simple">
<li>Common Lisp 提供整数 (integers)、比值 (ratios)、浮点数 (floating-point numbers)以及复数 (complex numbers)。</li>
<li>数字可以被约分或转换 (converted)，而它们的位数 (components)可以被取出。</li>
<li>用来比较数字的判断式可以接受任意数量的参数，以及比较下一数对 (successive pairs) –– <cite>/=</cite> 函数除外，它是用来比较所有的数对 (pairs)。</li>
<li>Common Lisp 几乎提供你在低阶科学计算机可以看到的数值函数。同样的函数普遍可应用在多种类型的数字上。</li>
<li>Fixnum 是小至可以塞入一个字 (word)的整数。它们在必要时会悄悄但花费昂贵地转成大数 (bignum)。Common Lisp 提供最多四种浮点数。每一个浮点表示法的限制是实现相关的 (implementation-dependent)常量。</li>
<li>一个光线追踪器 (ray-tracer)通过追踪光线来产生图像，使得每一像素回到模拟的世界。</li>
</ol>


<h1>Chapter 9 练习 (Exercises)</h1>
<ol class="arabic simple">
<li>定义一个函数，接受一个实数列表，若且唯若 (iff)它们是非递减 (nondecreasing)顺序时返回真。</li>
<li>定义一个函数，接受一个整数 <tt class="docutils literal">cents</tt> 并返回四个值，将数字用 <tt class="docutils literal">25-</tt> , <tt class="docutils literal">10-</tt> , <tt class="docutils literal">5-</tt> , <tt class="docutils literal">1-</tt> 来显示，使用最少数量的硬币。(译注: <tt class="docutils literal">25-</tt> 是 25 美分，以此类推)</li>
<li>一个遥远的星球住着两种生物， wigglies 与 wobblies 。 Wigglies 与 wobblies 唱歌一样厉害。每年都有一个比赛来选出十大最佳歌手。下面是过去十年的结果:</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">YEAR</th>
<th class="head">1</th>
<th class="head">2</th>
<th class="head">3</th>
<th class="head">4</th>
<th class="head">5</th>
<th class="head">6</th>
<th class="head">7</th>
<th class="head">8</th>
<th class="head">9</th>
<th class="head">10</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>WIGGLIES</td>
<td>6</td>
<td>5</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>5</td>
</tr>
<tr><td>WOBBLIES</td>
<td>4</td>
<td>5</td>
<td>4</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
写一个程序来模拟这样的比赛。你的结果实际上有建议委员会每年选出 10 个最佳歌手吗？<br/><br/>
<ol class="arabic simple" start="4">
<li>定义一个函数，接受 8 个表示二维空间中两个线段端点的实数，若线段没有相交，则返回假，或返回两个值表示相交点的 <tt class="docutils literal">x</tt> 座标与 <tt class="docutils literal">y</tt> 座标。</li>
<li>假设 <tt class="docutils literal">f</tt> 是一个接受一个 (实数) 参数的函数，而 <tt class="docutils literal">min</tt> 与 <tt class="docutils literal">max</tt> 是有着不同正负号的非零实数，使得 <tt class="docutils literal">f</tt> 对於参数 <tt class="docutils literal">i</tt> 有一个根 (返回零)并满足 <tt class="docutils literal">min &lt; i &lt; max</tt> 。定义一个函数，接受四个参数， <tt class="docutils literal">f</tt> , <tt class="docutils literal">min</tt> , <tt class="docutils literal">max</tt> 以及 <tt class="docutils literal">epsilon</tt> ，并返回一个 <tt class="docutils literal">i</tt> 的近似值，准确至正负 <tt class="docutils literal">epsilon</tt> 之内。</li>
<li><em>Honer's method</em> 是一个有效率求出多项式的技巧。要找到 <span class="math">
\(ax^3+bx^2+cx+d\)</span>
 你对 <tt class="docutils literal"><span class="pre">x(x(ax+b)+c)+d</span></tt> 求值。定义一个函数，接受一个或多个参数 –– x 的值伴随着 <em>n</em> 个实数，用来表示 <tt class="docutils literal"><span class="pre">(n-1)</span></tt> 次方的多项式的系数 –– 并用 <em>Honer's method</em> 计算出多项式的值。</li>
</ol>
译注: <a class="reference external" href="http://en.wikipedia.org/wiki/Horner's_method">Honer's method on wiki</a><br/><br/>
<ol class="arabic simple" start="7">
<li>你的 Common Lisp 实现使用了几个位元来表示定数 (fixnum)？</li>
<li>你的 Common Lisp 实现提供几种不同的浮点数？</li>
</ol>
脚注<br/><br/>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>当 <tt class="docutils literal">format</tt> 取整显示时，它不保证会取成偶数或奇数。见 125 页 (译注: 7.4 节)。</td></tr>
</tbody>
</table>
