---
layout: post
title : "第4章--特殊数据结构"
category : acl
tags : [acl]
---
{% include JB/setup %}

在之前的章节里，我们讨论了列表，Lisp 最多功能的数据结构。本章演示如何使用 Lisp 其它的数据结构：数组（包含向量与字串），结构以及哈希表。他们或许不像列表这么弹性，但他们可以更快地存取并使用更少空间。<br/><br/>
Common Lisp 有另一个数据结构：实例（instance）。实例在 11 章讨论，讲述 CLOS。<br/><br/>

<h1>4.1 数组 (Array)</h1>
在 Common Lisp 里，你可以调用 <tt class="docutils literal"><span class="pre">make-array</span></tt> 构造一个数组，第一个参数为一个列表，指定数组的维度。要构造一个 <tt class="docutils literal">2 x 3</tt> 的数组我们可以：<br/><br/>

&gt; (setf arr (make-array '(2 3) :initial-element nil))
#&lt;Simple-Array T (2 3) BFC4FE&gt;
</pre>
数组在 Common Lisp 里至少可以有七个维度，每个维度至少可以有 1023 个元素。<br/><br/>
<tt class="docutils literal"><span class="pre">:initial-element</span></tt> 参数是选择性的。如果提供了这个参数，整个数组会用指定的值作初始化。想要取出一个未初始化的数组内取出元素的行为，其结果为未定义（undefined）。<br/><br/>
取出数组内的元素我们调用 <tt class="docutils literal">aref</tt> 。跟 Common Lisp 的存取函数相同， <tt class="docutils literal">aref</tt> 是零索引的 (zero-indexed)：<br/><br/>

&gt; (aref arr 0 0)
NIL
</pre>
要替换数组的某个元素，我们使用 <tt class="docutils literal">setf</tt> 和 <tt class="docutils literal">aref</tt> ：<br/><br/>

&gt; (setf (aref arr 0 0) 'b)
B
&gt; (aref arr 0 0)
B
</pre>
要表示一个字面量数组 (literal array)，我们使用 <tt class="docutils literal">#na</tt> 语法，其中 n 是数组的维度。举例来说，我们可以这样表示一个跟 <tt class="docutils literal">arr</tt> 一样的数组：<br/><br/>

#2a((b nil nil) (nil nil nil))
</pre>
如果全局变量 <tt class="docutils literal"><span class="pre">*print-array*</span></tt> 为真，数组会用这种形式显示：<br/><br/>

&gt; (setf *print-array* t)
T
&gt; arr
#2A((B NIL NIL) (NIL NIL NIL))
</pre>
如果我们只想要一个一维的数组，你可以给 <tt class="docutils literal"><span class="pre">make-array</span></tt> 第一个参数一个整数，而不是一个列表：<br/><br/>

&gt; (setf vec (make-array 4 :initial-elment nil))
#(NIL NIL NIL NIL)
</pre>
一个一维数组又称为向量 ( <em>vector</em> )。你可以用一个步骤来构造及填满向量，藉由调用 <tt class="docutils literal">vector</tt> ，它会返回一个无论你给入什么参数的向量：<br/><br/>

&gt; (vector &quot;a&quot; 'b 3)
#(&quot;a&quot; b 3)
</pre>
一个字面量向量 (literal vector)可以用这种语法表达，如同字面量数组可以表示成 <tt class="docutils literal">#na</tt> 。<br/><br/>
你可以用 <tt class="docutils literal">aref</tt> 来存取向量，但有一个更快的函数叫做 <tt class="docutils literal">svref</tt> 给存取向量使用。<br/><br/>

&gt; (svref vec 0)
NIL
</pre>
在 <tt class="docutils literal">svref</tt> 内的 “sv” 代表“简单向量” (&quot;simple vector&quot;) ，它是所有向量的缺省值。 <a class="footnote-reference" href="#id4" id="id1">[1]</a><br/><br/>


<h1>4.2 示例：二分搜索 (Example: Binary Search)</h1>
作为一个示例，这小节演示如何写一个在排序好的向量里搜索一个对象的函数。如果我们知道一个向量是排序好的，我们可以比 <tt class="docutils literal">find</tt> (65页）做的更好， <tt class="docutils literal">find</tt> 必须依序检视每一个元素。取而代之的，我们跳到向量中间开始。如果中间的元素是我们要找的对象，搜索完毕。不然，我们持续往左半部或往右半部搜索，取决于​​对象是小于或大于中间的元素。<br/><br/>
图 4.1 包含了一个这样工作的函数。其实这两个函数： <tt class="docutils literal"><span class="pre">bin-search</span></tt> 设置初始范围及发送控制信号给 <tt class="docutils literal">finder</tt> ，它寻找向量 <tt class="docutils literal">vec</tt> 内 <tt class="docutils literal">obj</tt> 是否介于 <tt class="docutils literal">start</tt> 及 <tt class="docutils literal">end</tt> 之间。<br/><br/>

(defun bin-search (obj vec)
  (let ((len (length vec)))
    (and (not (zerop len))
         (finder obj vec 0 (- len 1)))))

(defun finder (obj vec start end)
  (let ((range (- end start)))
    (if (zerop range)
        (if (eql obj (aref vec start))
            obj
            nil)
        (let ((mid (+ start (round (/ range 2)))))
          (let ((obj2 (aref vec mid)))
            (if (&lt; obj obj2)
                (finder obj vec start (- mid 1))
                (if (&gt; obj obj2)
                    (finder obj vec (+ mid 1) end)
                    obj)))))))
</pre>
图 4.1: 搜索一个排序好的向量<br/><br/>
<strong>勘误:</strong> 图 4.1 的 <tt class="docutils literal"><span class="pre">bin-search</span></tt> 函数，如果你给一个比向量 <tt class="docutils literal">vec</tt> 中最小元素还小的元素，会出错。<br/><br/>
如果要找的 <tt class="docutils literal">range</tt> 缩小至一个元素，而如果这个元素是 <tt class="docutils literal">obj</tt> 的话，则 <tt class="docutils literal">finder</tt> 返回这个元素，反之返回 <tt class="docutils literal">nil</tt> 。如果 <tt class="docutils literal">range</tt> 包含了数个元素，我们設置 <tt class="docutils literal">middle</tt> ( <tt class="docutils literal">round</tt> 返回离参数最近的整数) 為 <tt class="docutils literal">obj2</tt> 。如果 <tt class="docutils literal">obj</tt> 小于 <tt class="docutils literal">obj2</tt> ，则继续递归地往向量的左半部寻找。如果 <tt class="docutils literal">obj</tt> 大于 <tt class="docutils literal">obj2</tt> ，则继续递回地往向量的右半部寻找。剩下的一个选择是 <tt class="docutils literal">obj=obj2</tt> ，这个情况我们找到要找的元素，直接返回这个元素。<br/><br/>
如果我们插入下面这行至 <tt class="docutils literal">finder</tt> 的起始处：<br/><br/>

(format t &quot;~A~%&quot; (subseq vec start (+ end 1)))
</pre>
我们可以观察被搜索的元素的数量是每一步往左减半的：<br/><br/>

&gt; (bin-search 3 #(0 1 2 3 4 5 6 7 8 9))
#(0 1 2 3 4 5 6 7 8 9)
#(0 1 2 3)
#(3)
3
</pre>


<h1>4.3 字符与字串 (Strings and Characters)</h1>
字串是字符向量。我们用一系列由双引号包住的字符来表示一个字串常量，一个字符 <tt class="docutils literal">c</tt> 用 <tt class="docutils literal">#\c</tt> 表示。<br/><br/>
每个字符都有一个相关的整数 –– 通常是用 ASCII 码，但不一定是。在多数的 Lisp 实现里，函数 <tt class="docutils literal"><span class="pre">char-code</span></tt> 返回与字符相关的数字，而 <tt class="docutils literal"><span class="pre">code-char</span></tt> 返回与数字相关的字符。<br/><br/>
字符比较函数 <tt class="docutils literal">char&lt;</tt> (小于)， <tt class="docutils literal">char&lt;=</tt> (小于等于)， <tt class="docutils literal">char=</tt> (等于)， <tt class="docutils literal">char&gt;=</tt> (大于等于) ， <tt class="docutils literal">char&gt;</tt> (大于)，以及 <tt class="docutils literal">char/=</tt> (不同)。他们的工作方式和 146 页(译注 9.3 节)的数字比较操作符一样。<br/><br/>

&gt; (sort &quot;elbow&quot; #'char&lt;)
&quot;below&quot;
</pre>
因为字串是向量，序列与数组的函数都可以给字串使用。你可以使用 <tt class="docutils literal">aref</tt> 来取出元素，举例来说，<br/><br/>

&gt; (aref &quot;abc&quot; 1)
#\b
</pre>
但对一个字串，你可以使用更快的 <tt class="docutils literal">char</tt> 函数：<br/><br/>

&gt; (char &quot;abc&quot; 1)
#\b
</pre>
你可以使用 <tt class="docutils literal">setf</tt> 搭配 <tt class="docutils literal">char</tt> (或 <tt class="docutils literal">aref</tt> )来替换元素：<br/><br/>

&gt; (let ((str (copy-seq &quot;Merlin&quot;)))
   (setf (char str 3) #\k)
   str)
</pre>
如果你想要比较两个字串，你可以使用通用的 <tt class="docutils literal">equal</tt> 函数，但还有一个忽略大小写的比较函数 <tt class="docutils literal"><span class="pre">string-equal</span></tt> ：<br/><br/>

&gt; (equal &quot;fred &quot;fred&quot;)
T
&gt; (equal &quot;fred&quot; &quot;Fred&quot;)
NIL
&gt;(string-equal &quot;fred&quot; &quot;Fred&quot;)
T
</pre>
Common Lisp 提供大量的操控及比较字串的函数。他们收录在附录D，从 364 页开始。<br/><br/>
有很多种方式可以创造一个字串。最普遍的方式是使用 <tt class="docutils literal">format</tt> 。将第一个参数设为 <tt class="docutils literal">nil</tt> 来调用 <tt class="docutils literal">format</tt> ，使它返回一个它本来会印出来的字串：<br/><br/>

&gt; (format nil &quot;~A or ~A&quot; &quot;truth&quot; &quot;dare&quot;)
&quot;truth or dare&quot;
</pre>
但若你只想把数个字串连结起来，你可以使用 <tt class="docutils literal">concatenate</tt> ，它接受一个指定類型的符号，加上一个或多个序列：<br/><br/>

&gt; (concatenate 'string &quot;not &quot; &quot;to worry&quot;)
&quot;not to worry&quot;
</pre>


<h1>4.4 序列 (Sequences)</h1>
在 Common Lisp 里，序列类型包含了列表与向量（因此也包含了字串）。有些我们在列表上使用的函数，其实是序列函数，包括 <tt class="docutils literal">remove</tt> , <tt class="docutils literal">length</tt> , <tt class="docutils literal">subseq</tt> , <tt class="docutils literal">reverse</tt> , <tt class="docutils literal">sort</tt> , <tt class="docutils literal">every</tt> 以及 <tt class="docutils literal">some</tt> 。所以 46 页（译注 3.11 小节的 <tt class="docutils literal">mirror?</tt> 函数）我们所写的函数，也可以用在别种序列上：<br/><br/>

&gt; (mirror? &quot;abba&quot;)
T
</pre>
我们已经看过四个用来取出序列元素的函数： 给列表使用的 <tt class="docutils literal">nth</tt> ， 给向量使用的 <tt class="docutils literal">aref</tt> 及 <tt class="docutils literal">svref</tt> ，以及给字串使用的 <tt class="docutils literal">char</tt> 。 Common Lisp 也提供了函数 <tt class="docutils literal">elt</tt> ，对任何种类的序列都有效：<br/><br/>

&gt; (elt '(a b c) 1)
B
</pre>
针对特定类型的序列，我们已经见过的存取函数应当比较快，所以使用 <tt class="docutils literal">elt</tt> 是没有意义的，除非在代码中，有要通用地支援序列的地方。<br/><br/>
使用 <tt class="docutils literal">elt</tt> ，我们可以写一个对向量来说更有效率的 <tt class="docutils literal">mirror?</tt> 版本：<br/><br/>

(defun mirror? (s)
  (let ((len (length s)))
    (and (evenp len)
         (do ((forward 0 (+ forward 1))
              (back (- len 1) (- back 1)))
             ((or (&gt; forward back)
                  (not (eql (elt s forward)
                            (elt s back))))
              (&gt; forward back))))))
</pre>
这个版本也可以给列表使用，但这个实现更适合给向量使用。频繁的对列表调用 <tt class="docutils literal">elt</tt> 的代价是昂贵的，因为列表仅允许循序存取。而向量允许随机存取，从任何元素来存取每一个元素都是廉价的(cheap)。<br/><br/>
许多序列函数接受一个或多个，从这个表格所列出的标准关键字参数：<br/><br/>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="50%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">参数</th>
<th class="head">用途</th>
<th class="head">缺省值</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>:key</td>
<td>应用至每个元素的函数</td>
<td>identity</td>
</tr>
<tr><td>:test</td>
<td>作来比较的函数</td>
<td>eql</td>
</tr>
<tr><td>:from-end</td>
<td>若为真，反向工作。</td>
<td>nil</td>
</tr>
<tr><td>:start</td>
<td>起始位置</td>
<td>0</td>
</tr>
<tr><td>:end</td>
<td>若有给定，结束位置。</td>
<td>nil</td>
</tr>
</tbody>
</table>
一个接受全部关键字参数的函数是 <tt class="docutils literal">position</tt> ，它返回序列中一个元素的位置，而未找到时，返回 <tt class="docutils literal">nil</tt> 。我们使用 <tt class="docutils literal">position</tt> 来演示关键字参数所扮演的角色。<br/><br/>

&gt; (position #\a &quot;fantasia&quot;)
1
&gt; (position #\a &quot;fantasia&quot; :start 3 :end 5)
4
</pre>
第二个例子我们要找在第四个与第六个字符间，第一个 <tt class="docutils literal">a</tt> ​​所出现的位置。 <tt class="docutils literal">:start</tt> 关键字参数是第一个被考虑的元素位置，缺省是序列的第一个元素。 <tt class="docutils literal">:end</tt> 关键字参数，如果有给的话，是第一个不被考虑的元素位置。<br/><br/>
如果我们给入 <tt class="docutils literal"><span class="pre">:from-end</span></tt> 关键字参数，<br/><br/>

&gt; (position #\a &quot;fantasia&quot; :from-end t)
7
</pre>
我们得到最靠近结尾的 <tt class="docutils literal">a</tt> ​​的位置。但位置是用平常的方式计算；它不代表从结尾算回来的距离。<br/><br/>
<tt class="docutils literal">:key</tt> 关键字参数是序列中每个元素在被考虑前，应用至元素的函数。如果我们询问像是这样的东西，<br/><br/>

&gt; (position 'a '((c d) (a b)) :key #'car)
1
</pre>
那么我们要找的是元素的 <tt class="docutils literal">car</tt> 部分是符号 <tt class="docutils literal">a</tt> ​​的第一个元素。<br/><br/>
<tt class="docutils literal">:test</tt> 关键字参数是一个有两个参数的函数，并定义了怎样是一个成功的匹配。它的缺省函数为 <tt class="docutils literal">eql</tt> 。如果你想要匹配一个列表，你也许想使用 <tt class="docutils literal">equal</tt> 来取代：<br/><br/>

&gt; (position '(a b) '((a b) (c d)))
NIL
&gt; (position '(a b) '((a b) (c d)) :test #'equal)
0
</pre>
<tt class="docutils literal">:test</tt> 关键字参数可以是任何接受两个参数的函数。举例来说，给定 <tt class="docutils literal">&lt;</tt> ，我们可以询问第一个使第一个参数比它小的元素位置：<br/><br/>

&gt; (position 3 '(1 0 7 5) :test #'&lt;)
2
</pre>
使用 <tt class="docutils literal">subseq</tt> 与 <tt class="docutils literal">position</tt> ，我们可以写出分开序列的函数。举例来说，这个函数<br/><br/>

(defun second-word (str)
  (let ((p1 (+ (position #\ str) 1)))
    (subseq str p1 (position #\ str :start p1))))
</pre>
返回字串中用空格隔开的第二个单字：<br/><br/>

&gt; (second-word &quot;Form follows function&quot;)
&quot;follows&quot;
</pre>
要找到满足接受一个参数的判断式的一个元素，我们使用 <tt class="docutils literal"><span class="pre">position-if</span></tt> 。它接受一个函数与一个序列，并返回第一个满足此函数的第一个元素：<br/><br/>

&gt; (position-if #'oddp '(2 3 4 5))
1
</pre>
它接受除了 <tt class="docutils literal">:test</tt> 之外的所有关键字参数。<br/><br/>
有许多相似的函数，如给序列使用的 <tt class="docutils literal">member</tt> 与 <tt class="docutils literal"><span class="pre">member-if</span></tt> 。它们分别是， <tt class="docutils literal">find</tt> （接受全部关键字参数）与 <tt class="docutils literal"><span class="pre">find-if</span></tt> （接受除了 <tt class="docutils literal">:test</tt> 之外的所有关键字参数）：<br/><br/>

&gt; (find #\a &quot;cat&quot;)
#\a

&gt; (find-if #'characterp &quot;ham&quot;)
#\h
</pre>
不像是 <tt class="docutils literal">member</tt> 与 <tt class="docutils literal"><span class="pre">member-if</span></tt> ，它们仅返回要寻找的对象。<br/><br/>
通常一个 <tt class="docutils literal"><span class="pre">find-if</span></tt> 的调用，如果解读为 <tt class="docutils literal">find</tt> 搭配一个 <tt class="docutils literal">:key</tt> 关键字参数的话，会显得更清楚。举例来说，表达式<br/><br/>

(find-if #'(lambda (x)
             (eql (car x) 'complete))
         lst)
</pre>
可以更好的解读为<br/><br/>

(find 'complete lst :key #'car)
</pre>
函数 <tt class="docutils literal">remove</tt> ( 22 页)以及 <tt class="docutils literal"><span class="pre">remove-if</span></tt> 通常都可以用在序列。它们跟 <tt class="docutils literal">find</tt> 与 <tt class="docutils literal"><span class="pre">find-if</span></tt> 是一样的关系。一个相关的函数是 <tt class="docutils literal"><span class="pre">remove-duplicates</span></tt> ，它只保留序列中每个元素的最后一次出现。<br/><br/>

&gt; (remove-duplicates &quot;abracadabra&quot;)
&quot;cdbra&quot;
</pre>
这个函数接受前表所列的所有关键字参数。<br/><br/>
函数 <tt class="docutils literal">reduce</tt> 用来把一个序列压缩成一个值。它接受至少两个参数，一个函数与一个序列。这函数必须是一个接受两个参数的函数。在最简单的情况下，函数起初用前两个元素作为参数来调用，之后接续的元素作为下次调用的第二个参数，而上次返回的值作为下次调用的第一个参数。最后调用所返回的值作为 <tt class="docutils literal">reduce</tt> 函数的返回值。也就是说像是这样的表达式：<br/><br/>

(reduce #'fn '(a b c d))
</pre>
等同于<br/><br/>

(fn (fn (fn 'a 'b) 'c) 'd)
</pre>
我们可以使用 <tt class="docutils literal">reduce</tt> 来扩充只接受两个参数的函数。举例来说，要得到三个或多个列表的交集(intersection)，我们可以：<br/><br/>

&gt; (reduce #'intersection '((b r a d 's) (bad) (cat)))
(A)
</pre>


<h1>4.5 示例：解析日期 (Example: Parsing Dates)</h1>
作为一个序列操作的例子，这小节演示了如何写一个程序来解析日期。我们将编写一个程序，可以接受一个像是 “16 Aug 1980” 的字串，然后返回一个表示日、月、年的整数列表。<br/><br/>

(defun tokens (str test start)
  (let ((p1 (position-if test str :start start)))
    (if p1
        (let ((p2 (position-if #'(lambda (c)
                                   (not (funcall test c)))
                               str :start p1)))
          (cons (subseq str p1 p2)
                (if p2
                    (tokens str test p2)
                    nil)))
        nil)))

(defun constituent (c)
  (and (graphic-char-p c)
       (not (char= c #\ ))))
</pre>
图 4.2 辨别符号 (token)<br/><br/>
图 4.2 中包含了某些我们在这应用里所需的通用解析函数。第一个， <tt class="docutils literal">tokens</tt> ，用来从字串中取出符号 (token)。给定一个字串及一个测试函数，它返回一个字符满足此函数的子字串的列表。举例来说，如果测试函数是对字母返回真的 <tt class="docutils literal"><span class="pre">alpha-char-p</span></tt> 函数，我们得到：<br/><br/>

&gt; (tokens &quot;ab12 3cde.f&quot; #'alpha-char-p 0)
(&quot;ab&quot; &quot;cde&quot; &quot;f&quot;)
</pre>
所有不满足此函数的字符被视为空白 –– 他们使符号 (token)分开，但永远不是符号 (token)的一部分。<br/><br/>
函数 <tt class="docutils literal">constituent</tt> 被定义成用来作为 <tt class="docutils literal">tokens</tt> 的参数。<br/><br/>
在 Common Lisp 里， <em>图形字符</em> 是我们可见的字符，加上空白字符。所以如果我们用 <tt class="docutils literal">constituent</tt> 作为测试函数时，<br/><br/>

&gt; (tokens &quot;ab12 3cde.f gh&quot; #'constituent 0)
(&quot;ab12&quot; &quot;3cde.f&quot; &quot;gh&quot;)
</pre>
则符号 (tokens)将会有一般常见的空白概念。<br/><br/>
图 4.3 包含了特别为解析日期用的函数。这函数 <tt class="docutils literal"><span class="pre">parse-date</span></tt> 接受一个特别形式的日期，并返回一个代表其组成的整数列表：<br/><br/>

&gt; (parse-date &quot;16 Aug 1980&quot;)
(16 8 1980)
</pre>

(defun parse-date (str)
  (let ((toks (tokens str #'constituent 0)))
    (list (parse-integer (first toks))
          (parse-month (second toks))
          (parse-integer (third toks)))))

(defconstant month-names
  #(&quot;jan&quot; &quot;feb&quot; &quot;mar&quot; &quot;apr&quot; &quot;may&quot; &quot;jun&quot;
    &quot;jul&quot; &quot;aug&quot; &quot;sep&quot; &quot;oct&quot; &quot;nov&quot; &quot;dec&quot;))

(defun parse-month (str)
  (let ((p (position str month-names
                         :test #'string-equal)))
    (if p
        (+ p 1)
        nil)))
</pre>
图 4.3 解析日期的函数<br/><br/>
它使用 <tt class="docutils literal">tokens</tt> 来解开一个日期字串，然后调用 <tt class="docutils literal"><span class="pre">parse-month</span></tt> 及 <tt class="docutils literal"><span class="pre">parse-integer</span></tt> 来解译这些元素。要找到月份，它调用 <tt class="docutils literal"><span class="pre">parse-month</span></tt> ，由于使用的是 <tt class="docutils literal"><span class="pre">string-equal</span></tt> 来匹配月份的名字，所以输入可以不分大小写。要找到年和日，它调用内建的 <tt class="docutils literal"><span class="pre">parse-integer</span></tt> ， <tt class="docutils literal"><span class="pre">parse-integer</span></tt> 接受一个字串并返回对应的整数。<br/><br/>
如果我们需要写程序来解析整数，我们也许可以：<br/><br/>

(defun read-integer (str)
  (if (every #'digit-char-p str)
      (let ((accum 0))
        (dotimes (pos (length str))
          (setf accum (+ (* accum 10)
                         (digit-char-p (char str pos)))))
        accum)
    nil))
</pre>
这个定义演示了在 Common Lisp 中，字符是如何转成数字的 – 函数 <tt class="docutils literal"><span class="pre">digit-char-p</span></tt> 不仅测试一个字符是否为数字，也返回了对应的整数。<br/><br/>


<h1>4.6 结构 (Structures)</h1>
结构可以想成是豪华版的向量。假设你要写一个程序来追踪很多长方体。你可能会想用三个向量元素来表示长方体：高度、宽度及深度。你的程序会变得更容易读，如果你与其使用原本的 <tt class="docutils literal">svrefs</tt> ，而定义一个像是这样<br/><br/>

(defun block-height (b) (svref b 0))
</pre>
等等的函数来取代。你可以把结构想成是，这些函数都替你定义好了的向量。<br/><br/>
要定义一个结构，我们使用 <tt class="docutils literal">defstruct</tt> 。在最简单的情况下，我们只要给出结构及栏位的名字就可以了：<br/><br/>

(defstruct point
  x
  y)
</pre>
这定义了一个 <tt class="docutils literal">point</tt> 具有两个栏位 <tt class="docutils literal">x</tt> 与 <tt class="docutils literal">y</tt> 。它也隐性地定义了 <tt class="docutils literal"><span class="pre">make-point</span></tt> , <tt class="docutils literal"><span class="pre">point-p</span></tt> , <tt class="docutils literal"><span class="pre">copy-point</span></tt> , <tt class="docutils literal"><span class="pre">point-x</span></tt> 及 <tt class="docutils literal"><span class="pre">point-y</span></tt> 函数。<br/><br/>
2.3 节提到 Lisp 程序可以写 Lisp 程序。这是我们目前所看过的明显例子之一。当你调用 <tt class="docutils literal">defstruct</tt> 时，它自动写好了其它几个函数的定义。有了宏，你将能够自己来办到同样的事情（如果你需要的话，你甚至可以自己写 <tt class="docutils literal">defstruct</tt> ）。<br/><br/>
每一个 <tt class="docutils literal"><span class="pre">make-point</span></tt> 的调用，会返回一个新的 <tt class="docutils literal">point</tt> 。我们可以藉由给予对应的关键字参数，来指定单一栏位的值：<br/><br/>

(setf p (make-point :x 0 :y 0))
#S(POINT X 0 Y 0)
</pre>
存取 <tt class="docutils literal">point</tt> 栏位的函数不仅被定义成可取出数值，也可以与 <tt class="docutils literal">setf</tt> 合作使用。<br/><br/>

&gt; (point-x p)
0
&gt; (setf (point-y p) 2)
2
&gt; p
#S(POINT X 0 Y 2)
</pre>
定义一个结构也定义了一个以此为名的类型。每个点会是类型 <tt class="docutils literal">point</tt> ，然后是 <tt class="docutils literal">structure</tt> ，接着是 <tt class="docutils literal">atom</tt> ，最后是 <tt class="docutils literal">t</tt> 。所以使用 <tt class="docutils literal"><span class="pre">point-p</span></tt> 来测试某个东西是不是一个点，也可以使用通用性的函数，像是 <tt class="docutils literal">typep</tt> 来测试。<br/><br/>
我们可以藉由在本来的定义中，附上一个含有栏位名及一个预设表达式的列表，来指定结构栏位的缺省值。<br/><br/>

(defstruct polemic
  (type (progn
          (format t &quot;What kind of polemic was it? &quot;)
          (read)))
  (effect nil))
</pre>
如果 <tt class="docutils literal"><span class="pre">make-polemic</span></tt> 调用没有替这些栏位指定初始值，他们会被设成对应表达式的值：<br/><br/>

&gt; (make-polemic)
What kind of polemic was it? scathing
#S(POLEMIC TYPE SCATHING EFFECT NIL)
</pre>
我们也可以控制结构显示的方式，以及结构产生的存取函数的字首。这里是一个更详细的做了这两件事的 <tt class="docutils literal">point</tt> 定义：<br/><br/>

(defstruct (point (:conc-name p)
                  (:print-function print-point))
  (x 0)
  (y 0))

(defun print-point (p stream depth)
  (format stream &quot;#&lt;~A, ~A&gt;&quot; (px p) (py p)))
</pre>
<tt class="docutils literal"><span class="pre">:conc-name</span></tt> 参数指定了要放在栏位名前面的名字，并用这些名字来生成存取函数。预设是 <tt class="docutils literal">point-</tt> ；现在变成只有 <tt class="docutils literal">p</tt> 。不使用预设的方式，使你的代码的可读性降低了一点，所以你只有在会常常用到这些存取函数时，你才会想做这类的事情。<br/><br/>
<tt class="docutils literal"><span class="pre">:print-function</span></tt> 是在它需要被显示时，要用来打印的函数 <em>名</em> –– 比如，顶层要显示时。这个函数需要接受三个参数：要被印出的结构，在哪里被印出，第三个参数通常可以被忽略。 <a class="footnote-reference" href="#id5" id="id2">[2]</a> 我们会在7.1 节讨论这些流(stream)。对现在来说，只要知道作为参数的流可以传给 <tt class="docutils literal">format</tt> 就好了。<br/><br/>
函数 <tt class="docutils literal"><span class="pre">print-point</span></tt> 会用缩写的形式来显示点：<br/><br/>

&gt; (make-point)
#&lt;0,0&gt;
</pre>


<h1>4.7 示例：二分搜索树 (Example: Binary Search Tree)</h1>
因为 <tt class="docutils literal">sort</tt> 本身是自带的，你会很少，如果有的话，需要在 Common Lisp 里编排序程序。本节演示如何解决一个相关的问题，这个问题尚未有现成的解决方案：维护一个已排序的对象集合。本节的代码会把对象存在二分搜索树里（ <em>binary search tree</em> ）或称作 BST。当二分搜索树平衡时，它允许我们可以在与时间成 <tt class="docutils literal">log n</tt> 比例的时间内，来寻找、添加或是删除元素，其中 <tt class="docutils literal">n</tt> 是集合的大小。<br/><br/>

<img alt="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-4.4.png" src="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-4.4.png" />

图 4.4: 二分搜索树<br/><br/>
一个二分搜索树是一种二叉树，其中给定某个排序函数 <tt class="docutils literal">&lt;</tt> ，每个元素的左子树都 <tt class="docutils literal">&lt;</tt> 该元素，而该元素 <tt class="docutils literal">&lt;</tt> 其右子树。图 4.4 展示一个根据 <tt class="docutils literal">&lt;</tt> 排序的示例。<br/><br/>
图 4.5 包含了二分搜索树中，插入与寻找的函数。基本的数据结构会是 <tt class="docutils literal">node</tt> （节点），它有三个栏位：一个是存在该节点的对象，以及各一个栏位，给节点的左子树及右子树。你可以把节点想成是有一个 <tt class="docutils literal">car</tt> 和两个 <tt class="docutils literal">cdr</tt> 的一个 cons 核（cons cell）。<br/><br/>

(defstruct (node (:print-function
                  (lambda (n s d)
                    (format s &quot;#&lt;~A&gt;&quot; (node-elt n)))))
  elt (l nil) (r nil))

(defun bst-insert (obj bst &lt;)
  (if (null bst)
      (make-node :elt obj)
      (let ((elt (node-elt bst)))
        (if (eql obj elt)
            bst
            (if (funcall &lt; obj elt)
                (make-node
                   :elt elt
                   :l (bst-insert obj (node-l bst) &lt;)
                   :r (node-r bst))
                (make-node
                   :elt elt
                   :r (bst-insert obj (node-r bst) &lt;)
                   :l (node-l bst)))))))

(defun bst-find (obj bst &lt;)
  (if (null bst)
      nil
      (let ((elt (node-elt bst)))
        (if (eql obj elt)
            bst
            (if (funcall &lt; obj elt)
                (bst-find obj (node-l bst) &lt;)
                (bst-find obj (node-r bst) &lt;))))))

(defun bst-min (bst)
  (and bst
       (or (bst-min (node-l bst)) bst)))

(defun bst-max (bst)
  (and bst
       (or (bst-max (node-r bst)) bst)))
</pre>
图 4.5 二分搜索树：查询与插入<br/><br/>
一个二分搜索树可以是 <tt class="docutils literal">nil</tt> 或是一个左子、右子树都是二分搜索树的节点。如同列表可由连续调用 <tt class="docutils literal">cons</tt> 来构造，二分搜索树将可以由连续调用 <tt class="docutils literal"><span class="pre">bst-insert</span></tt> 来构造。这个函数接受一个对象，一个二分搜索树及一个排序函数，并返回一个包含此对象的二分搜索树。和 <tt class="docutils literal">cons</tt> 函数一样， <tt class="docutils literal"><span class="pre">bst-insert</span></tt> 不改动做为第二个参数传入的二分搜索树。以下是我们如何使用它，来构造一个二分搜索树：<br/><br/>

&gt; (setf nums nil)
NIL
&gt; (dolist (x '(5 8 4 2 1 9 6 7 3))
    (setf nums (bst-insert x nums #'&lt;)))
NIL
</pre>
图 4.4 显示了此时 <tt class="docutils literal">nums</tt> 的结构所对应的树。<br/><br/>
我们可以使用 <tt class="docutils literal"><span class="pre">bst-find</span></tt> ，它与 <tt class="docutils literal"><span class="pre">bst-insert</span></tt> 接受同样的参数，来找到二分搜索树中的对象。先前叙述所提到的 <tt class="docutils literal">node</tt> 结构，它像是一个具有两个 <tt class="docutils literal">cdr</tt> 的 cons 核。如果我们把 16 页的 <tt class="docutils literal"><span class="pre">our-member</span></tt> 拿来与 <tt class="docutils literal"><span class="pre">bst-find</span></tt> 比较的话，这样的类比变得更清楚。<br/><br/>
和 <tt class="docutils literal">member</tt> 一样， <tt class="docutils literal"><span class="pre">bst-find</span></tt> 不仅返回要寻找的元素，也返回了被找元素做为根节点的子树：<br/><br/>

&gt; (bst-find 12 nums #'&lt;)
NIL
&gt; (bst-find 4 nums #'&lt;)
#&lt;4&gt;
</pre>
这让我们可以区分出无法找到某物以及成功找到 <tt class="docutils literal">nil</tt> 的情况。<br/><br/>
要找到二分搜索树的最小及最大的元素是很简单的。要找到最小的，我们随着左子的路径走，如同 <tt class="docutils literal"><span class="pre">bst-min</span></tt> 所做的。要找到最大的，我们随着右子的路径走，如同 <tt class="docutils literal"><span class="pre">bst-max</span></tt> 所做的：<br/><br/>

&gt; (bst-min nums)
#&lt;1&gt;
&gt; (bst-max nums)
#&lt;12&gt;
</pre>
要从二分搜索树移除一个元素一样很快，但需要更多代码。图 4.6 演示了如何做到这件事。<br/><br/>

(defun bst-remove (obj bst &lt;)
  (if (null bst)
      nil
      (let ((elt (node-elt bst)))
        (if (eql obj elt)
            (percolate bst)
            (if (funcall &lt; obj elt)
                (make-node
                   :elt elt
                   :l (bst-remove obj (node-l bst) &lt;)
                   :r (node-r bst))
                (make-node
                   :elt elt
                   :r (bst-remove obj (node-r bst) &lt;)
                   :l (node-l bst)))))))

(defun percolate (bst)
  (cond ((null (node-l bst))
         (if (null (node-r bst))
             nil
             (rperc bst)))
        ((null (node-r bst)) (lperc bst))
        (t (if (zerop (random 2))
               (lperc bst)
               (rperc bst)))))

(defun rperc (bst)
  (make-node :elt (node-elt (node-r bst))
             :l (node-l bst)
             :r (percolate (node-r bst))))
</pre>
图 4.6 二分搜索树：删除<br/><br/>
<strong>勘误:</strong> 此版 <tt class="docutils literal"><span class="pre">bst-remove</span></tt> 的定义已被回报是坏掉的，请参考 <a class="reference external" href="https://gist.github.com/2868263">这里</a> 获得一个修补后的版本。<br/><br/>
函数 <tt class="docutils literal"><span class="pre">bst-remove</span></tt> 接受一个对象，一个二分搜索树以及一个排序函数，并返回一个像是本来的二分搜索树，但不含那个要移除的对象。跟 <tt class="docutils literal">remove</tt> 一样，它不改动做为第二个参数传入的二分搜索树：<br/><br/>

&gt; (setf nums (bst-remove 2 nums #'&lt;))
#&lt;5&gt;
&gt; (bst-find 2 nums #'&lt;)
NIL
</pre>
此时 <tt class="docutils literal">nums</tt> 应有像是图 4.7 所显示的结构。 （另一个可能性是 <tt class="docutils literal">1</tt> 取代了 <tt class="docutils literal">2</tt> 的位置。）<br/><br/>

<img alt="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-4.7.png" src="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-4.7.png" />

图 4.7: 二分搜索树<br/><br/>
删除需要更多工作因为从内部节点移除一个对象，会留下一个空缺，需要由其中一个孩子来填补。这是 <tt class="docutils literal">percolate</tt> 函数的用途。它替换一个二分搜索树的树根（topmost element）时，用其中一个孩子来替换，并用此孩子的孩子来填补，如此这般一直做下去。<br/><br/>
为了要保持树的平衡，如果有两个孩子时， <tt class="docutils literal">perlocate</tt> 随机择一替换。表达式 <tt class="docutils literal">(random 2)</tt> 会返回 <tt class="docutils literal">0</tt> 或 <tt class="docutils literal">1</tt> ，所以 <tt class="docutils literal">(zerop (random 2))</tt> 会返回真或假。<br/><br/>

(defun bst-traverse (fn bst)
  (when bst
    (bst-traverse fn (node-l bst))
    (funcall fn (node-elt bst))
    (bst-traverse fn (node-r bst))))
</pre>
图 4.8 二分搜索树：遍歷<br/><br/>
一旦我们把一个对象集合插入至二分搜索树时，中序遍歷会将它们由小至大排序。这是图 4.8 中， <tt class="docutils literal"><span class="pre">bst-traverse</span></tt> 函数的用途：<br/><br/>

&gt; (bst-traverse #'princ nums)
13456789
NIL
</pre>
（函数 <tt class="docutils literal">princ</tt> 仅显示一个单一对象）<br/><br/>
本节所给出的代码，提供了一个二分搜索树实作的骨架。你可能想根据应用需求，来充实其骨架。举例来说，这里所给出的代码每个节点只有一个 <tt class="docutils literal">elt</tt> 栏位；在许多应用里，有两个栏位会更有意义， <tt class="docutils literal">key</tt> 与 <tt class="docutils literal">value</tt> 。本章的这个版本把二分搜索树视为集合看待，从这个角度看，重复的插入是被忽略的。但是代码可以很简单地改动，来处理重复的元素。<br/><br/>
二分搜索树不仅是维护一个已排序对象的集合的方法。他们是否是最好的方法，取决于你的应用。一般来说，二分搜索树最适合用在插入与删除是均匀分布的情况。有一件他们不适合的事，是用来维护优先队列（priority queues）。在一个优先队列里，插入也许是均匀分布的，但删除总是在一个末端。这会导致一个二分搜索树变得不平衡，而我们所期望的复杂度是 <tt class="docutils literal">O(log(n))</tt> 插入与删除操作，会变成 <tt class="docutils literal">O(n)</tt> 。如果你用二分搜索树来表示一个优先队列，你也可以使用一般的列表，因为二分搜索树最终会作用的像个列表。<br/><br/>


<h1>4.8 哈希表 (Hash Table)</h1>
第三章演示了列表可以用来表示集合（sets）与映射（mappings）。当列表的长度大幅上升时（或是 10 个元素），使用哈希表会来得比较快。你透过调用 <tt class="docutils literal"><span class="pre">make-hash-table</span></tt> 来构造一个哈希表，它不需要传入参数：<br/><br/>

&gt; (setf ht (make-hash-table))
#&lt;Hash-Table BF0A96&gt;
</pre>
和函数一样，哈希表总是用 <tt class="docutils literal"><span class="pre">#&lt;...&gt;</span></tt> 的形式来显示。<br/><br/>
一个哈希表，像是一个关联列表，是一种表达相关对象的方式。要取出与一给定键值有关的数值，我们调用 <tt class="docutils literal">gethash</tt> 并传入一个键值与哈希表。预设情况下，如果没有与这个键值相关的数值， <tt class="docutils literal">gethash</tt> 会返回 <tt class="docutils literal">nil</tt> 。<br/><br/>

&gt; (gethash 'color ht)
NIL
NIL
</pre>
在这里我们首次看到 Common Lisp 最突出的特色之一：一个表达式可以返回多个数值。函数 <tt class="docutils literal">gethash</tt> 返回两个数值。第一个值是与键值有关的数值，第二个值说明了哈希表是否有任何用此键值来储存的数值。因为第二个值是 <tt class="docutils literal">nil</tt> ，我们知道第一个 <tt class="docutils literal">nil</tt> 是预设的返回值，而不是因为 <tt class="docutils literal">nil</tt> 是与 <tt class="docutils literal">color</tt> 有关的数值。<br/><br/>
大部分的实作会在顶层显示一个函数调用的所有返回值，但仅期待一个返回值的程式码，会只收到第一个返回值。 5.5 节会说明程式码是如何接收多个返回值。<br/><br/>
要把一个数值与键值作关联，我们使用 <tt class="docutils literal">gethash</tt> 搭配 <tt class="docutils literal">setf</tt> ：<br/><br/>

&gt; (setf (gethash 'color ht) 'red)
RED
</pre>
现在如果我们再次调用 <tt class="docutils literal">gethash</tt> ，我们会得到我们刚插入的值：<br/><br/>

&gt; (gethash 'color ht)
RED
T
</pre>
第二个返回值证明，我们取得了一个真正储存的对象，而不是预设值。<br/><br/>
存在哈希表的对象或是键值可以是任何型别。举例来说，如果我们要保留函数的某种讯息，我们可以使用一个哈希表，用函数做为键值，字串做为词条（entry）：<br/><br/>

&gt; (setf bugs (make-hash-table))
#&lt;Hash-Table BF4C36&gt;
&gt; (push &quot;Doesn't take keyword arguments.&quot;
        (gethash #'our-member bugs))
(&quot;Doesn't take keyword arguments.&quot;)
</pre>
由于 <tt class="docutils literal">gethash</tt> 预设返回 <tt class="docutils literal">nil</tt> ，而 <tt class="docutils literal">push</tt> 是 <tt class="docutils literal">setf</tt> 的缩写，我们可以简单地把新的字串推入一个函数的词条。 （有困扰的 <tt class="docutils literal"><span class="pre">our-member</span></tt> 定义在 16 页。）<br/><br/>
你可以用哈希表取代列表来表示集合。当集合变大时，哈希表的查询与删除应该比较快。要新增一个成员到用哈希表所表示的集合，把 <tt class="docutils literal">gethash</tt> 用 <tt class="docutils literal">setf</tt> 设成 <tt class="docutils literal">t</tt> ：<br/><br/>

&gt; (setf fruit (make-hash-table))
#&lt;Hash-Table BFDE76&gt;
&gt; (setf (gethash 'apricot fruit) t)
T
</pre>
然后要测试是否为成员，你只要调用：<br/><br/>

&gt; (gethash 'apricot fruit)
T
T
</pre>
由于 <tt class="docutils literal">gethash</tt> 预设返回真，一个新创的哈希表，很方便地是一个空集合。<br/><br/>
要从集合中移除一个对象，你可以调用 <tt class="docutils literal">remhash</tt> ，它从一个哈希表中移除一个词条 (entry):<br/><br/>

&gt; (remhash 'apricot fruit)
T
</pre>
返回值说明了那里是否有词条被移除；在这个情况里，有。<br/><br/>
哈希表有一个迭代函数： <tt class="docutils literal">maphash</tt> ，它接受一个两个参数的函数及一个哈希表。函数会被每个键值对调用，没有特定的顺序：<br/><br/>

&gt; (setf (gethash 'shape ht) 'spherical
        (gethash 'size ht) 'giant)
GIANT

&gt; (maphash #'(lambda (k v)
               (format t &quot;~A = ~A~%&quot; k v))
           ht)
SHAPE = SPHERICAL
SIZE = GIANT
COLOR = RED
NIL
</pre>
它总是返回 <tt class="docutils literal">nil</tt> ，但你可以透过传入一个会累积数值的函数，把它们存在一个列表里。<br/><br/>
哈希表可以容纳任何数目的元素，因为当空间用完时，它们会被扩张。如果你想要确保一个哈希表，从特定数目的元素空间开始时，你可以给一个选择性的 <tt class="docutils literal">:size</tt> 参数给 <tt class="docutils literal"><span class="pre">make-hash-table</span></tt> 。做这件事情有两个理由：因为你知道哈希表会变得很大，你想要避免扩张它；或是因为你知道哈希表会是很小，你不想要浪费记忆体。 <tt class="docutils literal">:size</tt> 参数不仅指定了哈希表的空间，也指定了元素的数量。平均来说，在被扩张前所能够容纳的数量。所以<br/><br/>
<tt class="docutils literal"><span class="pre">(make-hash-table</span> :size 5)</tt><br/><br/>
会返回一个预期存放五个元素的哈希表。<br/><br/>
和任何牵涉到查询的结构一样，哈希表一定有某种比较键值的概念。预设是使用 <tt class="docutils literal">eql</tt> ，但你可以提供一个额外的参数 <tt class="docutils literal">:test</tt> 来告诉一个哈希表要使用 <tt class="docutils literal">eq</tt> ， <tt class="docutils literal">equal</tt> ，还是 <tt class="docutils literal">equalp</tt> ：<br/><br/>

&gt; (setf writers (make-hash-table :test #'equal))
#&lt;Hash-Table C005E6&gt;
&gt; (setf (gethash '(ralph waldo emerson) writers) t)
T
</pre>
这是一个我们要使哈希表有效率的取舍之一。有了列表，我们可以指定 <tt class="docutils literal">member</tt> 来判断相等的判断式。有了哈希表，我们可以预先决定，并在哈希表构造时指定它。<br/><br/>
大多数 Lisp 编程的取舍（或是生活，就此而论）都有这种特质。起初你想要事情进行得流畅，甚至赔上效率的代价。之后当程式码变得沉重时，你牺牲了弹性来换取速度。<br/><br/>


<h1>Chapter 4 总结 (Summary)</h1>
<ol class="arabic simple">
<li>Common Lisp 支援至少 7 个维度的数组。一维数组称为向量。</li>
<li>字串是字符的向量。字符本身就是对象。</li>
<li>序列包括了向量与列表。许多序列函数都接受标准的关键字参数。</li>
<li>因为有许多函数都支援字串，所以在 Lisp 里做解析是容易的。</li>
<li>调用 <tt class="docutils literal">defstruct</tt> 定义了一个带有命名栏位的结构。它是一个程序能写出程序的好例子。</li>
<li>二分搜索树见长于维护一个已排序的对象集合。</li>
<li>哈希表提供了一个更有效率的方式来表示集合与映射 (mappings)。</li>
</ol>


<h1>Chapter 4 习题 (Exercises)</h1>
<ol class="arabic simple">
<li>定义一个函数，接受一个平方数组（square array, 一个相同维度的数组 <tt class="docutils literal">(n n)</tt> )，并将它顺时针转 90 度。</li>
</ol>

&gt; (quarter-turn #2A((a b) (c d)))
#2A((C A) (D B))
</pre>
你会需要用到 361 页的 <tt class="docutils literal"><span class="pre">array-dimensions</span></tt> 。<br/><br/>
<ol class="arabic simple" start="2">
<li>阅读 368 页的 <tt class="docutils literal">reduce</tt> 说明，然后用它来定义：</li>
</ol>

(a) copy-list
(b) reverse（针对列表）
</pre>
<ol class="arabic simple" start="3">
<li>定义一个结构来表示一个树，其中每个节点包含某些数据及三个小孩。定义：</li>
</ol>

(a) 一个函数来复制这样的树（复制完的节点与本来的节点是不相等(eql)的）
(b) 一个函数，接受一个对象与这样的树，如果对象与树中各节点的其中一个栏位相等时，返回真。
</pre>
<ol class="arabic simple" start="4">
<li>定义一个函数，接受一个二分搜索树，并返回由此树元素所组成的，一个由大至小排序的列表。</li>
<li>定义 <tt class="docutils literal"><span class="pre">bst-adjoin</span></tt> 。这个函数应与 <tt class="docutils literal"><span class="pre">bst-insert</span></tt> 接受相同的参数，但应该只在对象不等于任何树中对象时将其插入。</li>
</ol>
<strong>勘误:</strong> <tt class="docutils literal"><span class="pre">bst-adjoin</span></tt> 的功能与 <tt class="docutils literal"><span class="pre">bst-insert</span></tt> 一模一样。<br/><br/>
<ol class="arabic simple" start="6">
<li>任何哈希表的内容可以由关联列表(assoc-list)来描述，其中列表的元素是 <tt class="docutils literal">(k . v)</tt> 的形式，对应到哈希表中的每一个键值对。定义一个函数：</li>
</ol>

(a) 接受一个关联列表，并返回一个对应的哈希表。
(b) 接受一个哈希表，并返回一个对应的关联列表。
</pre>
脚注<br/><br/>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>一个简单的数组是不可调整的(neither adjustable)、不可替换的(nor displaced)，且没有填充指针(fill-pointer)。数组缺省是简单的。一个简单向量是一个一维简单数组，可以含有任何类型的元素。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>在 Ansi Common Lisp 里，你可以给一个 <tt class="docutils literal"><span class="pre">:print-object</span></tt> 的关键字参数来取代，它只需要两个参数。也有一個宏叫做 <tt class="docutils literal"><span class="pre">print-unreadable-object</span></tt> ，在可用时，应该要使用这个，可以用 <tt class="docutils literal"><span class="pre">#&lt;...&gt;</span></tt> 的语法来显示对象。</td></tr>
</tbody>
</table>
