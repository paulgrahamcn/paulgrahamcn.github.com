---
layout: post
title : "第8章--符号"
category : acl
tags : [acl]
---
{% include JB/setup %}

符号我们已经用了好长一段时间。蕴藏在符号背後还有更多。起初或许最好不要纠结背後的实现机制。你可以像数据对象与名字那样使用符号，而不需要理解两者是如何相关联的。但到了某个时候，停下来并思考背後是如何工作是很有用的。这个章节解释了背後的细节。<br/><br/>

<h1>8.1 符号名 (Symbol Names)</h1>
第二章描述过符号是用来作为变量名，而符号本身是以一个对象所存在。但 Lisp 符号的可能性，要比在多数语言仅允许作为变量名来得广泛许多。实际上，一个符号可以用任何字串作为名称。你可以通过调用 <tt class="docutils literal"><span class="pre">symbol-name</span></tt> 来获得符号的名字：<br/><br/>

&gt; (symbol-name 'abc)
&quot;ABC&quot;
</pre>
注意到这个符号的名字全部是大写字母。缺省情况下 Common Lisp 在读入时，把符号名字所有的英文字母都转成大写。这表示 Common Lisp 缺省是不分大小写的：<br/><br/>

&gt; (eql 'abc 'Abc)
T
&gt; (CaR '(a b c))
A
</pre>
有一个特殊的语法用来参照符号，其名字包含空白或其他可能对於读取器 (reader)重要的字符。任何存在垂直杠 (vertical bar)之间的字符序列 (sequence of characters)被视为一个符号。你可以这样子在符号的名字中放入任何东西：<br/><br/>

&gt; (list '|Lisp 1.5| '|| '|abc| '|ABC|)
(|Lisp 1.5| || |abc| ABC)
</pre>
当这样的符号名读入时，不会有大小写转换，而宏字符和其他的字符被视为一般字符。<br/><br/>
那什麽样的符号不需要使用垂直杠来参照呢？基本上任何不是数字或不包含读取器视为重要的字符的符号。一个快速找出你是否可以不用垂直杠来参照符号的方法，是看看 Lisp 如何印出它的。如果 Lisp 没有用垂直杠表示一个符号，如上述列表的最後一个，那麽你也可以不用垂直杠。<br/><br/>
记得垂直杠是一个特殊的语法来表示符号。它们不是符号的名字之一：<br/><br/>

&gt; (symbol-name '|a b c|)
&quot;a b c&quot;
</pre>
(如果你想要在符号名使用垂直杠，你可以放一个反斜线在垂直杠的前面。)<br/><br/>
译注: 反斜线是 <tt class="docutils literal">\</tt> (backslash)。<br/><br/>


<h1>8.2 属性列表 (Property Lists)</h1>
在 Common Lisp 里，每一个符号都有一个属性列表 (property-list) 或称为 <tt class="docutils literal">plist</tt> 。函数 <tt class="docutils literal">get</tt> 接受一个符号及一个任何类型的键值，然後返回在符号的属性列表中，与键值相关的数值：<br/><br/>

&gt; (get 'alizarin 'color)
NIL
</pre>
它使用 <tt class="docutils literal">eql</tt> 来比较各个键。若某个特定的属性没有找到时， <tt class="docutils literal">get</tt> 返回 <tt class="docutils literal">nil</tt> 。<br/><br/>
要将一个值与一个键关联起来时，你可以使用 <tt class="docutils literal">setf</tt> 及 <tt class="docutils literal">get</tt> :<br/><br/>

&gt; (setf (get 'alizarin 'color) 'red)
RED
&gt; (get 'alizarin 'color)
RED
</pre>
现在符号 <tt class="docutils literal">alizarin</tt> 的 <tt class="docutils literal">color</tt> 属性是 <tt class="docutils literal">red</tt> 。<br/><br/>

<img alt="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-8.1.png" src="https://github.com/acl-translation/acl-chinese/raw/master/images/Figure-8.1.png" />

<strong>图 8.1 符号的结构</strong><br/><br/>

&gt; (setf (get 'alizarin 'transparency) 'high)
HIGH
&gt; (symbol-plist 'alizarin)
(TRANSPARENCY HIGH COLOR RED)
</pre>
注意到属性列表不以关联列表 (assoc-lists)的形式表示，虽然他们用起来是一样的。（译注: 关联列表在 3.14 节讨论过）<br/><br/>
在 Common Lisp 里，属性列表用得不多。他们大部分被哈希表取代了 (4.8 小节)。<br/><br/>


<h1>8.3 符号很不简单 (Symbols Are Big)</h1>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch8-cn.rst</tt>, line 90)<br/><br/>
Title underline too short.<br/><br/>

8.3 符号很不简单 (Symbols Are Big)
================================
</pre>

当我们输入名字时，符号就被悄悄地产生出来了，而当它们被显示时，我们只能看到符号的名字。某些情况下，把符号想成是我们所看到的东西就好，别想太多。但有时候符号不像看起来那麽简单。<br/><br/>
从我们如何使用及检视符号，看起来符号像是整数那样的小对象。实际上符号确实是一个对象，差不多像是由 <tt class="docutils literal">defstruct</tt> 定义的那种结构。一个符号可以有名字、 <tt class="docutils literal">home</tt> 包 (package)、作为变量的值、作为函数的值以及一个属性列表 (property list)。图 8.1 展示了符号在内部是如何表示的。<br/><br/>
很少有程序会使用很多符号，以致於值得用其它的来代替符号以节省空间。但是值得铭记在心的是，符号是实际的对象，不只是名字而已。当两个变量设成相同的符号时，与两个变量设成相同列表一样：两个变量都有指针指向同样的对象。<br/><br/>


<h1>8.4 创建符号 (Creating Symbols)</h1>
8.1 节演示了如何从符号获得它的名字。另一方面，从字串获得符号也是有可能的。这比较复杂一点，因为我们需要介绍包 (package)这个议题。<br/><br/>
概念上包是将名字映射到符号的符号表 (symbol-tables)。每一个普通的符号都属於一个特定的包。一个符号属於一个包，我们称为符号被包 interned 了。函数与变量用符号作为它们的名字。包藉由限制哪个符号可以存取来实施模组化 (modularity)，也是因为这样，我们才可以参照到函数与变量。<br/><br/>
大多数的符号在读取时被 interned 了。在你第一次输入一个新符号的名字时，Lisp 会产生一个新的符号对象，并将它 intern 到当下的包里（缺省是 <tt class="docutils literal"><span class="pre">common-lisp-user</span></tt> 包)。但你也可以透过给入一个字串与选择性包参数 (optional package argument)给 <tt class="docutils literal">intern</tt> 函数来 intern 一个符号:<br/><br/>

&gt; (intern &quot;RANDOM-SYMBOL&quot;)
RANDOM-SYMBOL
NIL
</pre>
包参数缺省是当前的包，所以前述的表达式，返回当前包里的一个符号，此符号的名字是 &quot;RANDOM-SYMBOL&quot;，若此符号尚未存在时，会创造一个这样的符号出来。第二个返回值告诉我们符号是否存在；在这个情况，它不存在。<br/><br/>
不是所有的符号都会被 interned。有时候有一个 uninterned 符号是有用的，这和有未公开的电话是一样的原因。Uninterned 符号叫做 <em>gensyms</em> 。我们将会在第 10 章讨论宏 (Macro)时，理解 gensym 的作用。<br/><br/>


<h1>8.5 多重包 (Multiple Packages)</h1>
大的程序通常分割成多个包。如果程序的每一部分都是一个包，那麽开发程序另一个部分的某个人，将可以使用符号来作为函数名或变量名，而不用担心名字在别的地方已经被用到了。<br/><br/>
在没有提供定义多个命名空间的语言里，工作於大项目的程序员，通常需要想出某些规范 (convention)来确保他们不会使用同样的名称。举例来说，程序员写显示用的代码 (display code)可能用 <tt class="docutils literal">disp_</tt> 开头的名字，而写数学程序 (math code)的程序员仅使用由 <tt class="docutils literal">math_</tt> 开始的代码。所以若是数学程序里包含一个函数来做快速傅立叶转换 (fast Fourier transform)时，可能会叫做 <tt class="docutils literal">math_fft</tt> 。<br/><br/>
包只不过是提供了一种方式来自动办到这件事。如果你将函数定义在单独的包里，你可以随意使用你喜欢的名字。只有你显式 <tt class="docutils literal">export</tt> 的符号会被别的包看到，而他们通常前面会有包的名字(或修饰名)。<br/><br/>
举例来说，假设一个程序分成两个包， <tt class="docutils literal">math</tt> 与 <tt class="docutils literal">disp</tt> 。如果符号 <tt class="docutils literal">fft</tt> 被 <tt class="docutils literal">math</tt> 包输出，则 <tt class="docutils literal">disp</tt> 包里可以用 <tt class="docutils literal">math:fft</tt> 来参照它。在 <tt class="docutils literal">math</tt> 包里，可以只用 <tt class="docutils literal">fft</tt> 来参照。<br/><br/>
这里是你或许会放在文件最上方，包含独立包的代码:<br/><br/>

(defpackage &quot;MY-APPLICATION&quot;
            (:use &quot;COMMON-LISP&quot; &quot;MY-UTILITIES&quot;)
            (:nicknames &quot;APP&quot;)
            (:export &quot;WIN&quot; &quot;LOSE&quot; &quot;DRAW&quot;))

(in-package my-application)
</pre>
<tt class="docutils literal">defpackage</tt> 定义一个新的包叫做 <tt class="docutils literal"><span class="pre">my-application</span></tt> <a class="footnote-reference" href="#id3" id="id1">[1]</a> 它使用了其他两个包， <tt class="docutils literal"><span class="pre">common-lisp</span></tt> 与 <tt class="docutils literal"><span class="pre">my-utilities</span></tt> ，这代表着可以不需要用包修饰符 (package qualifiers)来存取这些包所输出的符号。许多包会使用 <tt class="docutils literal"><span class="pre">common-lisp</span></tt> –– 因为你不会想给 Lisp 内建的运算元与变量加上修饰符。<br/><br/>
<tt class="docutils literal"><span class="pre">my-application</span></tt> 包本身只输出三个符号: <tt class="docutils literal">WIN</tt> , <tt class="docutils literal">LOSE</tt> 以及 <tt class="docutils literal">DRAW</tt> 。由於调用 <tt class="docutils literal">defpackage</tt> 给了 <tt class="docutils literal"><span class="pre">my-application</span></tt> 一个匿称 <tt class="docutils literal">app</tt> ，别的包的程序可以这样参照到这些符号，比如 <tt class="docutils literal">app:win</tt> 。<br/><br/>
<tt class="docutils literal">defpackage</tt> 伴随着一个 <tt class="docutils literal"><span class="pre">in-package</span></tt> ，确保当前包是 <tt class="docutils literal"><span class="pre">my-application</span></tt> 。所有其它未修饰的符号会被 interned 至 <tt class="docutils literal"><span class="pre">my-application</span></tt> –– 除非之後有别的 <tt class="docutils literal"><span class="pre">in-package</span></tt> 。当一个文件被载入时，当前的包总是被重置成载入之前的值。<br/><br/>


<h1>8.6 关键字 (Keywords)</h1>
在 <tt class="docutils literal">keyword</tt> 包的符号 (称为关键字)有两个独特的性质：它们总是对自己求值，以及你可以在任何地方参照它们，如 <tt class="docutils literal">:x</tt> 而不是 <tt class="docutils literal">keyword:x</tt> 。我们首次在 44 页 (译注: 3.10 小节）介绍关键字参数时， <tt class="docutils literal">(member '(a) <span class="pre">'((a)</span> (z)) test: #'equal)</tt> 比 <tt class="docutils literal">(member '(a) <span class="pre">'((a)</span> (z)) :test #'equal)</tt> 读起来更自然。现在我们知道为什麽第二个较别扭的形式才是对的。 <tt class="docutils literal">test</tt> 前的冒号字首，是用来识别这是一个关键字。<br/><br/>
为什麽使用关键字而不用一般的符号？因为他们在哪都可以存取。一个函数接受符号作为参数，应该要写成预期关键字的函数。举例来说，函数可以安全地在任何包里调用:<br/><br/>

(defun noise (animal)
  (case animal
    (:dog :woof)
    (:cat :meow)
    (:pig :oink)))
</pre>
如果是用一般符号写成的话，它只会在被定义的包内工作，除非关键字也被输出 (exported)了。<br/><br/>


<h1>8.7 符号与变量 (Symbols and Variables)</h1>
Lisp 有一个可能会困惑你的事情是，符号与变量的从两个非常不同的层面互相关联。当一个符号是一个特别变量 (special variable)的名字时，变量的值存在符号的 value 栏位 (图 8.1)。 <tt class="docutils literal"><span class="pre">symbol-value</span></tt> 函数参照到那个栏位，所以在符号与特殊变量的值之间，有一个直接的连接 (connection)。<br/><br/>
而对於词法变量 (lexical variables)来说，事情就完全不一样了。一个作为词法变量的符号只是一个占位符 (placeholder)。编译器会将其转为一个暂存器 (register)或内存位置的参照。在最後编译出来的代码，我们无法追踪这个符号 (除非它被除错器「debugger」在某个地方保有着)。因此符号与词法变量的值之间是没有连接的；只要一有值，符号就消失了。<br/><br/>


<h1>8.8 示例：随机文本 (Example: Random Text)</h1>

System Message: WARNING/2 (<tt class="docutils">../acl-chinese/zhCN/ch8-cn.rst</tt>, line 170)<br/><br/>
Title underline too short.<br/><br/>

8.8 示例：随机文本 (Example: Random Text)
=======================================
</pre>

如果你要写程序来操作单词，通常使用符号会比字串来得好，因为符号概念上是原子的 (atomic)。(译注: 原子的意思即像一个原子是一个最小不可分割的单元。) 符号可以用 <tt class="docutils literal">eql</tt> 一步比较完成，而字串需要使用 <tt class="docutils literal">string=</tt> 或 <tt class="docutils literal"><span class="pre">string-equal</span></tt> 逐一字符做比较。作为一个例子，本节演示如何写一个程序来产生随机文字。程序的第一部分会读入一个示例文件 (越大越好)，用来累积之後所给入的相关单词的可能性 (likeilhood)的资讯。第二部分在每一个单词都根据原本的示例，产生一个随机的权重 (weight)之後，随机走访根据第一部分所产生的网络。<br/><br/>
产生的文字将会是部分可信的 (locally plausible)，因为任两个出现的单词也是输入文件里，两个同时出现的单词。令人惊讶的是你可以频繁地获得看起来是 –– 有意义的整句 –– 甚至整个段落。<br/><br/>
图 8.2 包含了程序的上半部，用来读取示例文件的代码。<br/><br/>

(defparameter *words* (make-hash-table :size 10000))

(defconstant maxword 100)

(defun read-text (pathname)
  (with-open-file (s pathname :direction :input)
    (let ((buffer (make-string maxword))
          (pos 0))
      (do ((c (read-char s nil :eof)
              (read-char s nil :eof)))
          ((eql c :eof))
        (if (or (alpha-char-p c) (char= c #\'))
            (progn
              (setf (aref buffer pos) c)
              (incf pos))
            (progn
              (unless (zerop pos)
                (see (intern (string-downcase
                               (subseq buffer 0 pos))))
                (setf pos 0))
              (let ((p (punc c)))
                (if p (see p)))))))))

(defun punc (c)
  (case c
    (#\. '|.|) (#\, '|,|) (#\; '|;|)
    (#\! '|!|) (#\? '|?|) ))

(let ((prev `|.|))
  (defun see (symb)
    (let ((pair (assoc symb (gethash prev *words*))))
      (if (null pair)
          (push (cons symb 1) (gethash prev *words*))
          (incf (cdr pair))))
    (setf prev symb)))
</pre>
<strong>图 8.2 读取示例文件</strong><br/><br/>
从图 8.2 导出的数据会被存在哈希表 <tt class="docutils literal">*words*</tt> 里。这个哈希表的键是代表单词的符号，而值会像是下列的关联列表 (assoc-lists):<br/><br/>

((|sin| . 1) (|wide| . 2) (|sights| . 1))
</pre>
使用<a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%A4%B1%E6%A8%82%E5%9C%92">弥尔顿的失乐园</a>作为示例文件时，这是与键 <tt class="docutils literal">|discover|</tt> 有关的值。它指出了 “discover” 这个单词，在诗里面用了四次，与 “wide” 用了两次，而 “sin” 与 ”sights” 各一次。(译注: 诗可以在这里找到 <a class="reference external" href="http://www.paradiselost.org/">http://www.paradiselost.org/</a> )<br/><br/>
函数 <tt class="docutils literal"><span class="pre">read-text</span></tt> 累积了这个资讯。这函数接受一个路径名 (pathname)，然後替每一个出现在文件中的单词，建立一个上面所展示的关联列表。它的工作方式是每次读取文件的一个字符，将累积的单词存在字串 <tt class="docutils literal">buffer</tt> 。有了 <tt class="docutils literal">maxword=100</tt> ，程序可以读取至多至 100 个字的单词，对英语来说足够了。<br/><br/>
只要下个字符是一个字 (由 <tt class="docutils literal"><span class="pre">alpha-char-p</span></tt> 决定)或是一撇 (apostrophe)，就持续累积字符。任何使单词停止累积的字符会送给 <tt class="docutils literal">see</tt> 。数种标点符号 (punctuation)也被认为是单词；函数 <tt class="docutils literal">punc</tt> 返回标点字符的伪单词 (pseudo-word)。<br/><br/>
函数 <tt class="docutils literal">see</tt> 注册每一个我们看过的字。它需要知道前一个单词以及我们刚确认过的单词 –– 这也是为什麽要有变量 <tt class="docutils literal">prev</tt> 。起初这个变量设为伪单词里的句点；在 <tt class="docutils literal">see</tt> 函数被调用後， <tt class="docutils literal">prev</tt> 变量包含了我们最後见过的单词。<br/><br/>
在 <tt class="docutils literal"><span class="pre">read-text</span></tt> 返回之後， <em>words</em> 会包含一个给输入文件的每一个单词的条目 (entry)。透过调用 <tt class="docutils literal"><span class="pre">hash-table-count</span></tt> 你可以了解有多少个不同的单词存在。很少英文文件会超过 10000 个单词。<br/><br/>
现在来到了有趣的部份。图 8.3 包含了从图 8.2 所累积的数据来产生文字的代码。 <tt class="docutils literal"><span class="pre">generate-text</span></tt> 函数导出整个过程。它接受一个要产生几个单词的数字，以及选择性传入前一个单词。使用缺省值，会让产生出来的文件从句子的开头开始。<br/><br/>

(defun generate-text (n &amp;optional (prev '|.|))
  (if (zerop n)
      (terpri)
      (let ((next (random-next prev)))
        (format t &quot;~A &quot; next)
        (generate-text (1- n) next))))

(defun random-next (prev)
  (let* ((choices (gethash prev *words*))
         (i (random (reduce #'+ choices
                            :key #'cdr))))
    (dolist (pair choices)
      (if (minusp (decf i (cdr pair)))
          (return (car pair))))))
</pre>
<strong>图 8.3 产生文字</strong><br/><br/>
要取得一个新的单词， <tt class="docutils literal"><span class="pre">generate-text</span></tt> 使用前一个单词调用 <tt class="docutils literal"><span class="pre">random-next</span></tt> 。这个函数随机选择伴随输入文本中 <tt class="docutils literal">prev</tt> 之后的单词，根据每个单词出现的机率加上权重。<br/><br/>
现在会是让程序来测试运行的好时机。但其实你已经看过一个它所产生的例子: 本书开头的那首诗，是使用弥尔顿的失乐园作为输入文件所产生的。<br/><br/>
(译注: 诗在这里或是书的第 vi 页)<br/><br/>
Half lost on my firmness gains more glad heart,<br/><br/>
Or violent and from forage drives<br/><br/>
A glimmering of all sun new begun<br/><br/>
Both harp thy discourse they match'd,<br/><br/>
Forth my early, is not without delay;<br/><br/>
For their soft with whirlwind; and balm.<br/><br/>
Undoubtedly he scornful turn'd round ninefold,<br/><br/>
Though doubled now what redounds,<br/><br/>
And chains these a lower world devote, yet inflicted?<br/><br/>
Till body or rare, and best things else enjoy'd in heav'n<br/><br/>
To stand divided light at ev'n and poise their eyes,<br/><br/>
Or nourish, lik'ning spiritual, I have thou appear.<br/><br/>
–– Henley<br/><br/>


<h1>Chapter 8 总结 (Summary)</h1>
<ol class="arabic simple">
<li>一个符号的名字可以是任何字串，但由 <tt class="docutils literal">read</tt> 创造的符号缺省会被转成大写。</li>
<li>符号有相关联的属性列表，虽然他们不需要是同样的形式，但行为像是 assoc-lists 。</li>
<li>符号是实质的对象，比较像结构而不是名字。</li>
<li>包将字串映射至符号。要在包里给符号创造一个条目的方法是 intern 它。符号不需要被 interned。</li>
<li>包通过限制可以参照的名称增加模组化。缺省你的包会是 user 包，但为了提高模组化，大的程序通常分成数个包。</li>
<li>可以让符号在别的包被存取。关键字是自身求值并在所有的包里都可以存取。</li>
<li>当一个程序用来操作单词时，用符号来表示单词是很方便的。</li>
</ol>


<h1>Chapter 8 练习 (Exercises)</h1>
<ol class="arabic simple">
<li>可能有两个符号有同样的名字，但是不 <tt class="docutils literal">eql</tt> 吗？</li>
<li>估计一下用字串表示 &quot;FOO&quot; 与符号表示 foo 所使用内存空间的差异。</li>
<li>137 页的 <tt class="docutils literal">defpackage</tt> 调用只使用字串作为参数。我们应该使用符号。为什麽使用字串可能比较危险呢？</li>
<li>加入需要的代码，使图 7.1 的代码可以放在一个叫做 <tt class="docutils literal">&quot;RING&quot;</tt> 的包里，而图 7.2 的代码放在一个叫做 <tt class="docutils literal">&quot;FILE&quot;</tt> 包里。你不需要更改现有的代码。</li>
<li>写一个可以确认引用的句子是否由 Henley 是否程序 (8.8 节)。</li>
<li>写一个 Henley，可以接受一个单词，并产生一个包含该单词於中间的句子的版本。</li>
</ol>
脚注<br/><br/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>调用 <tt class="docutils literal">defpackage</tt> 里的名字全部大写是因为在 8.1 节提到过，符号的名字缺省被转成大写。</td></tr>
</tbody>
</table>
