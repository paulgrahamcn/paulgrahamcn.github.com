---
layout: post
title : "Appendix B. Lisp in Lisp"
category : acl
tags : [acl]
---
{% include JB/setup %}

这个附录包含了 58 个最常用的 Common Lisp 操作符。因为如此多的 Lisp 是（或可以）用 Lisp 所写成，而由於 Lisp 程序（或可以）相当精简，这是一种方便解释语言的方式。<br/><br/>
这个练习也证明了，概念上 Common Lisp 不像看起来那样庞大。许多 Common Lisp 操作符是有用的函式库；要写出所有其它的东西，你所需要的操作符相当少。在这个附录的这些定义只需要:<br/><br/>
<tt class="docutils literal">apply</tt> <tt class="docutils literal">aref</tt> <tt class="docutils literal">backquote</tt> <tt class="docutils literal">block</tt> <tt class="docutils literal">car</tt> <tt class="docutils literal">cdr</tt> <tt class="docutils literal">ceiling</tt> <tt class="docutils literal">char=</tt> <tt class="docutils literal">cons</tt> <tt class="docutils literal">defmacro</tt> <tt class="docutils literal">documentation</tt> <tt class="docutils literal">eq</tt> <tt class="docutils literal">error</tt> <tt class="docutils literal">expt</tt> <tt class="docutils literal">fdefinition</tt> <tt class="docutils literal">function</tt> <tt class="docutils literal">floor</tt> <tt class="docutils literal">gensym</tt> <tt class="docutils literal"><span class="pre">get-setf-expansion</span></tt> <tt class="docutils literal">if</tt> <tt class="docutils literal">imagpart</tt> <tt class="docutils literal">labels</tt> <tt class="docutils literal">length</tt> <tt class="docutils literal"><span class="pre">multiple-value-bind</span></tt> <tt class="docutils literal"><span class="pre">nth-value</span></tt> <tt class="docutils literal">quote</tt> <tt class="docutils literal">realpart</tt> <tt class="docutils literal"><span class="pre">symbol-function</span></tt> <tt class="docutils literal">tagbody</tt> <tt class="docutils literal"><span class="pre">type-of</span></tt> <tt class="docutils literal">typep</tt> <tt class="docutils literal">=</tt> <tt class="docutils literal">+</tt> <tt class="docutils literal">-</tt> <tt class="docutils literal">/</tt> <tt class="docutils literal">&lt;</tt> <tt class="docutils literal">&gt;</tt><br/><br/>
这里给出的代码作为一种解释 Common Lisp 的方式，而不是实现它的方式。在实际的实现上，这些操作符可以更高效，也会做更多的错误检查。为了方便参找，这些操作符本身按字母顺序排列。如果你真的想要这样定义 Lisp，每个宏的定义需要在任何呼叫它们的代码之前。<br/><br/>

<pre>
(defun -abs (n)
  (if (typep n 'complex)
      (sqrt (+ (expt (realpart n) 2) (expt (imagpart n) 2)))
      (if (&lt; n 0) (- n) n)))
</pre>

<pre>
(defun -adjoin (obj lst &amp;rest args)
  (if (apply #'member obj lst args) lst (cons obj lst)))
</pre>

<pre>
(defmacro -and (&amp;rest args)
  (cond ((null args) t)
        ((cdr args)  `(if ,(car args) (-and ,&#64;(cdr args))))
        (t           (car args))))
</pre>

<pre>
(defun -append (&amp;optional first &amp;rest rest)
  (if (null rest)
      first
      (nconc (copy-list first) (apply #'-append rest))))
</pre>

<pre>
(defun -atom (x) (not (consp x)))
</pre>

<pre>
(defun -butlast (lst &amp;optional (n 1))
  (nreverse (nthcdr n (reverse lst))))
</pre>

<pre>
(defun -cadr (x) (car (cdr x)))
</pre>

<pre>
(defmacro -case (arg &amp;rest clauses)
  (let ((g (gensym)))
    `(let ((,g ,arg))
       (cond ,&#64;(mapcar #'(lambda (cl)
                           (let ((k (car cl)))
                             `(,(cond ((member k '(t otherwise))
                                       t)
                                      ((consp k)
                                       `(member ,g ',k))
                                      (t `(eql ,g ',k)))
                               (progn ,&#64;(cdr cl)))))
                       clauses)))))
</pre>

<pre>
(defun -cddr (x) (cdr (cdr x)))
</pre>

<pre>
(defun -complement (fn)
  #'(lambda (&amp;rest args) (not (apply fn args))))
</pre>

<pre>
(defmacro -cond (&amp;rest args)
  (if (null args)
      nil
      (let ((clause (car args)))
        (if (cdr clause)
            `(if ,(car clause)
                 (progn ,&#64;(cdr clause))
                 (-cond ,&#64;(cdr args)))
            `(or ,(car clause)
                 (-cond ,&#64;(cdr args)))))))
</pre>

<pre>
(defun -consp (x) (typep x 'cons))
</pre>

<pre>
(defun -constantly (x) #'(lambda (&amp;rest args) x))
</pre>

<pre>
(defun -copy-list (lst)
  (labels ((cl (x)
             (if (atom x)
                 x
                 (cons (car x)
                       (cl (cdr x))))))
    (cons (car lst)
          (cl (cdr lst)))))
</pre>

<pre>
(defun -copy-tree (tr)
  (if (atom tr)
      tr
      (cons (-copy-tree (car tr))
            (-copy-tree (cdr tr)))))
</pre>

<pre>
(defmacro -defun (name parms &amp;rest body)
  (multiple-value-bind (dec doc bod) (analyze-body body)
    `(progn
       (setf (fdefinition ',name)
             #'(lambda ,parms
                 ,&#64;dec
                 (block ,(if (atom name) name (second name))
                   ,&#64;bod))
             (documentation ',name 'function)
             ,doc)
       ',name)))
</pre>

<pre>
(defun analyze-body (body &amp;optional dec doc)
  (let ((expr (car body)))
    (cond ((and (consp expr) (eq (car expr) 'declare))
           (analyze-body (cdr body) (cons expr dec) doc))
          ((and (stringp expr) (not doc) (cdr body))
           (if dec
               (values dec expr (cdr body))
               (analyze-body (cdr body) dec expr)))
          (t (values dec doc body)))))
</pre>

<pre>
(defmacro -do (binds (test &amp;rest result) &amp;rest body)
  (let ((fn (gensym)))
    `(block nil
       (labels ((,fn ,(mapcar #'car binds)
                   (cond (,test ,&#64;result)
                         (t (tagbody ,&#64;body)
                            (,fn ,&#64;(mapcar #'third binds))))))
         (,fn ,&#64;(mapcar #'second binds))))))
</pre>

<pre>
(defmacro -dolist ((var lst &amp;optional result) &amp;rest body)
  (let ((g (gensym)))
    `(do ((,g ,lst (cdr ,g)))
         ((atom ,g) (let ((,var nil)) ,result))
       (let ((,var (car ,g)))
         ,&#64;body))))
</pre>

<pre>
(defun -eql (x y)
  (typecase x
    (character (and (typep y 'character) (char= x y)))
    (number    (and (eq (type-of x) (type-of y))
                    (= x y)))
    (t         (eq x y))))
</pre>

<pre>
(defun -evenp (x)
  (typecase x
    (integer (= 0 (mod x 2)))
    (t       (error &quot;non-integer argument&quot;))))
</pre>

<pre>
(defun -funcall (fn &amp;rest args) (apply fn args))
</pre>

<pre>
(defun -identity (x) x)
</pre>

<pre>
(defmacro -let (parms &amp;rest body)
  `((lambda ,(mapcar #'(lambda (x)
                         (if (atom x) x (car x)))
                     parms)
      ,&#64;body)
    ,&#64;(mapcar #'(lambda (x)
                  (if (atom x) nil (cadr x)))
              parms)))
</pre>

<pre>
(defun -list (&amp;rest elts) (copy-list elts))
</pre>

<pre>
(defun -listp (x) (or (consp x) (null x)))
</pre>

<pre>
(defun -mapcan (fn &amp;rest lsts)
  (apply #'nconc (apply #'mapcar fn lsts)))
</pre>

<pre>
(defun -mapcar (fn &amp;rest lsts)
  (cond ((member nil lsts) nil)
        ((null (cdr lsts))
         (let ((lst (car lsts)))
           (cons (funcall fn (car lst))
                 (-mapcar fn (cdr lst)))))
        (t
         (cons (apply fn (-mapcar #'car lsts))
               (apply #'-mapcar fn
                      (-mapcar #'cdr lsts))))))
</pre>

<pre>
(defun -member (x lst &amp;key test test-not key)
  (let ((fn (or test
                (if test-not
                    (complement test-not))
                    #'eql)))
    (member-if #'(lambda (y)
                   (funcall fn x y))
               lst
               :key key)))
</pre>

<pre>
(defun -member-if (fn lst &amp;key (key #'identity))
  (cond ((atom lst) nil)
        ((funcall fn (funcall key (car lst))) lst)
        (t (-member-if fn (cdr lst) :key key))))
</pre>

<pre>
(defun -mod (n m)
  (nth-value 1 (floor n m)))
</pre>

<pre>
(defun -nconc (&amp;optional lst &amp;rest rest)
  (if rest
      (let ((rest-conc (apply #'-nconc rest)))
        (if (consp lst)
            (progn (setf (cdr (last lst)) rest-conc)
                   lst)
            rest-conc))
      lst))
</pre>

<pre>
(defun -not (x) (eq x nil))
(defun -nreverse (seq)
  (labels ((nrl (lst)
             (let ((prev nil))
               (do ()
                   ((null lst) prev)
                 (psetf (cdr lst) prev
                        prev      lst
                        lst       (cdr lst)))))
           (nrv (vec)
             (let* ((len (length vec))
                    (ilimit (truncate (/ len 2))))
               (do ((i 0 (1+ i))
                    (j (1- len) (1- j)))
                   ((&gt;= i ilimit) vec)
                 (rotatef (aref vec i) (aref vec j))))))
    (if (typep seq 'vector)
        (nrv seq)
        (nrl seq))))
</pre>

<pre>
(defun -null (x) (eq x nil))
</pre>

<pre>
(defmacro -or (&amp;optional first &amp;rest rest)
  (if (null rest)
      first
      (let ((g (gensym)))
        `(let ((,g ,first))
           (if ,g
               ,g
               (-or ,&#64;rest))))))
</pre>
这两个 Common Lisp 没有，但这里有几的定义会需要用到。<br/><br/>

<pre>
(defun pair (lst)
  (if (null lst)
      nil
      (cons (cons (car lst) (cadr lst))
            (pair (cddr lst)))))

</pre>
<pre>
(defun -pairlis (keys vals &amp;optional alist)
  (unless (= (length keys) (length vals))
    (error &quot;mismatched lengths&quot;))
  (nconc (mapcar #'cons keys vals) alist))
</pre>

<pre>
(defmacro -pop (place)
  (multiple-value-bind (vars forms var set access)
                       (get-setf-expansion place)
    (let ((g (gensym)))
      `(let* (,&#64;(mapcar #'list vars forms)
              (,g ,access)
              (,(car var) (cdr ,g)))
         (prog1 (car ,g)
                ,set)))))
</pre>

<pre>
(defmacro -prog1 (arg1 &amp;rest args)
  (let ((g (gensym)))
    `(let ((,g ,arg1))
       ,&#64;args
       ,g)))
</pre>

<pre>
(defmacro -prog2 (arg1 arg2 &amp;rest args)
  (let ((g (gensym)))
    `(let ((,g (progn ,arg1 ,arg2)))
       ,&#64;args
       ,g)))
</pre>

<pre>
(defmacro -progn (&amp;rest args) `(let nil ,&#64;args))
</pre>

<pre>
(defmacro -psetf (&amp;rest args)
  (unless (evenp (length args))
    (error &quot;odd number of arguments&quot;))
  (let* ((pairs (pair args))
         (syms (mapcar #'(lambda (x) (gensym))
                       pairs)))
    `(let ,(mapcar #'list
                   syms
                   (mapcar #'cdr pairs))
       (setf ,&#64;(mapcan #'list
                       (mapcar #'car pairs)
                       syms)))))
</pre>

<pre>
(defmacro -push (obj place)
  (multiple-value-bind (vars forms var set access)
                       (get-setf-expansion place)
    (let ((g (gensym)))
      `(let* ((,g ,obj)
              ,&#64;(mapcar #'list vars forms)
              (,(car var) (cons ,g ,access)))
         ,set))))
</pre>

<pre>
(defun -rem (n m)
  (nth-value 1 (truncate n m)))

</pre>
<pre>
(defmacro -rotatef (&amp;rest args)
  `(psetf ,&#64;(mapcan #'list
                    args
                    (append (cdr args)
                            (list (car args))))))
</pre>

<pre>
(defun -second (x) (cadr x))

</pre>
<pre>
(defmacro -setf (&amp;rest args)
  (if (null args)
      nil
      `(setf2 ,&#64;args)))
</pre>

<pre>
(defmacro setf2 (place val &amp;rest args)
  (multiple-value-bind (vars forms var set)
                       (get-setf-expansion place)
    `(progn
       (let* (,&#64;(mapcar #'list vars forms)
              (,(car var) ,val))
         ,set)
       ,&#64;(if args `((setf2 ,&#64;args)) nil))))
</pre>

<pre>
(defun -signum (n)
  (if (zerop n) 0 (/ n (abs n))))
</pre>

<pre>
(defun -stringp (x) (typep x 'string))
</pre>

<pre>
(defun -tailp (x y)
  (or (eql x y)
      (and (consp y) (-tailp x (cdr y)))))
</pre>

<pre>
(defun -third (x) (car (cdr (cdr x))))
</pre>

<pre>
(defun -truncate (n &amp;optional (d 1))
  (if (&gt; n 0) (floor n d) (ceiling n d)))
</pre>

<pre>
(defmacro -typecase (arg &amp;rest clauses)
  (let ((g (gensym)))
    `(let ((,g ,arg))
       (cond ,&#64;(mapcar #'(lambda (cl)
                           `((typep ,g ',(car cl))
                             (progn ,&#64;(cdr cl))))
                       clauses)))))
</pre>

<pre>
(defmacro -unless (arg &amp;rest body)
  `(if (not ,arg)
       (progn ,&#64;body)))
</pre>

<pre>
(defmacro -when (arg &amp;rest body)
  `(if ,arg (progn ,&#64;body)))
</pre>

<pre>
(defun -1+ (x) (+ x 1))
</pre>

<pre>
(defun -1- (x) (- x 1))
</pre>

<pre>
(defun -&gt;= (first &amp;rest rest)
  (or (null rest)
      (and (or (&gt; first (car rest)) (= first (car rest)))
           (apply #'-&gt;= rest))))
</pre>
